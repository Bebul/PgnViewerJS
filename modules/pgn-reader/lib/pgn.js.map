{"version":3,"sources":["webpack://pgn-parser/webpack/universalModuleDefinition","webpack://pgn-parser/webpack/bootstrap","webpack://pgn-parser/./node_modules/@mliebelt/pgn-parser/pgn-parser.js","webpack://pgn-parser/./node_modules/chess.js/chess.js","webpack://pgn-parser/./src/pgn.js"],"names":["root","factory","exports","module","define","amd","global","installedModules","__webpack_require__","moduleId","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","peg$SyntaxError","message","expected","found","location","this","Error","captureStackTrace","child","parent","ctor","constructor","peg$subclass","buildMessage","DESCRIBE_EXPECTATION_FNS","literal","expectation","literalEscape","text","escapedParts","parts","length","Array","classEscape","inverted","any","end","other","description","hex","ch","charCodeAt","toString","toUpperCase","replace","j","descriptions","type","sort","slice","join","describeExpected","describeFound","SyntaxError","parse","input","options","peg$result","peg$FAILED","peg$startRuleFunctions","pgn","peg$parsepgn","tags","peg$parsetags","game","s0","s1","s2","peg$currPos","moves","peg$startRuleFunction","peg$c1","head","peg$c43","peg$literalExpectation","peg$c45","peg$c47","peg$c49","peg$c51","peg$c53","peg$c55","peg$c57","peg$c59","peg$c61","peg$c63","peg$c65","peg$c67","peg$c69","peg$c71","peg$c73","peg$c75","peg$c77","peg$c79","peg$c81","peg$c83","peg$c85","peg$c87","peg$c89","peg$c91","peg$c93","peg$c95","peg$c97","peg$c99","peg$c101","peg$c103","peg$c105","peg$c107","peg$c109","peg$c111","peg$c113","peg$c115","peg$c116","peg$otherExpectation","peg$c117","peg$c118","peg$classExpectation","peg$c119","peg$c122","peg$c123","peg$c124","peg$c125","peg$c126","peg$c128","peg$c132","peg$c135","peg$c137","peg$c139","peg$c141","peg$c143","peg$c145","peg$c146","digits","parseInt","peg$c161","peg$c162","peg$c170","peg$c173","peg$c175","peg$c176","cf","cfl","arr","push","peg$c180","peg$c183","peg$c186","peg$c189","peg$c193","peg$c195","peg$c197","peg$c199","peg$c201","peg$c204","peg$c207","peg$c210","peg$c213","peg$c216","peg$c222","peg$c224","peg$c226","peg$c228","peg$c234","peg$c237","peg$c240","peg$c242","peg$c243","peg$c245","peg$c247","peg$c249","peg$c253","peg$c256","peg$c259","peg$c262","peg$c265","peg$c268","peg$c271","peg$c274","peg$c276","peg$c278","peg$c280","peg$c282","peg$c286","peg$c289","peg$c292","peg$c295","peg$c298","peg$c302","peg$c305","peg$c308","peg$c311","peg$c314","peg$c317","peg$c320","peg$c322","peg$c323","peg$c324","peg$c325","peg$c326","peg$c327","peg$c328","peg$c329","peg$c331","peg$posDetailsCache","line","column","peg$maxFailPos","peg$maxFailExpected","peg$silentFails","startRule","ignoreCase","peg$computePosDetails","pos","details","peg$computeLocation","startPos","endPos","startPosDetails","endPosDetails","start","offset","peg$fail","peg$buildStructuredError","s3","s4","s5","s7","members","result","peg$parsews","peg$parsetag","concat","forEach","element","peg$parsebl","substr","peg$parseeventKey","peg$parsestring","peg$parsesiteKey","peg$c6","peg$parsedateKey","peg$parsedate","peg$c7","peg$parseroundKey","peg$c8","peg$parsewhiteKey","peg$c9","peg$parseblackKey","peg$c10","peg$parseresultKey","peg$parsequotation_mark","peg$parseinner_result","peg$parseresult","peg$c11","peg$parsewhiteTitleKey","peg$c12","peg$parseblackTitleKey","peg$c13","peg$parsewhiteEloKey","peg$parseintegerOrDash","peg$c14","peg$parseblackEloKey","peg$c15","peg$parsewhiteUSCFKey","peg$parseintegerString","peg$c16","peg$parseblackUSCFKey","peg$c17","peg$parsewhiteNAKey","peg$c18","peg$parseblackNAKey","peg$c19","peg$parsewhiteTypeKey","peg$c20","peg$parseblackTypeKey","peg$c21","peg$parseeventDateKey","peg$c22","peg$parseeventSponsorKey","peg$c23","peg$parsesectionKey","peg$c24","peg$parsestageKey","peg$c25","peg$parseboardKey","peg$c26","peg$parseopeningKey","peg$c27","peg$parsevariationKey","peg$c28","peg$parsesubVariationKey","peg$c29","peg$parseecoKey","peg$c30","peg$parsenicKey","peg$c31","peg$parsetimeKey","peg$c32","peg$parseutcTimeKey","peg$c33","peg$parseutcDateKey","peg$c34","peg$parsetimeControlKey","peg$c35","peg$parsesetUpKey","peg$c36","peg$parsefenKey","peg$c37","peg$parseterminationKey","peg$c38","peg$parseanotatorKey","peg$c39","peg$parsemodeKey","peg$c40","peg$parseplyCountKey","peg$c41","peg$parsetagKeyValue","peg$parsebr","test","charAt","peg$parsechar","s6","s8","month","day","pw","peg$parsepgnWhite","peg$parsepgnStartWhite","peg$parsepgnBlack","unshift","peg$parsepgnStartBlack","pb","all","peg$c148","peg$parsewhiteSpace","s9","s10","s11","s12","s13","s14","s15","s16","s17","cm","cb","hm","nag","ca","cd","vari","move","peg$parsecomments","peg$parsemoveNumber","peg$parsehalfMove","peg$parsenags","peg$parsecommentDiag","peg$parsevariationWhite","peg$parsepl","peg$parsepr","moveNumber","notation","commentBefore","commentAfter","commentMove","variations","commentDiag","peg$parseendGame","peg$parsevariationBlack","peg$parsecomment","comm","peg$c160","peg$parsecl","peg$parsecr","trim","peg$parsecommentAnnotation","cal","peg$c165","peg$parsecommentAnnotations","ret","peg$parsecolorField","peg$parsecolorFields","peg$parsecommentAnnotationFields","colorFields","peg$parsecolorArrow","peg$parsecolorArrows","peg$parsecommentAnnotationArrows","caa","colorArrows","peg$c167","peg$parseclockCommand","peg$parsedigit","h1","h2","m1","m2","peg$c217","peg$parseclockValue","cc","cv","peg$c202","peg$parsecommentAnnotationClock","cac","clock","peg$c168","peg$parsecolor","peg$parsefield","peg$parsecolumn","peg$parserow","peg$parseinteger","peg$parsedotOrWhitespace","peg$parsedot","fig","disc","str","col","row","pr","peg$parsefigure","peg$parsediscriminator","peg$parsestrike","peg$parsecheckdisc","peg$parsepromotion","peg$parsecheck","strike","check","promotion","peg$parsestrikeOrDash","cols","rows","peg$c231","peg$c232","peg$c235","peg$c238","peg$parsepromFigure","peg$parsenag","Chess","fen","DEFAULT_POSITION","POSSIBLE_RESULTS","PAWN_OFFSETS","b","w","PIECE_OFFSETS","q","k","ATTACKS","RAYS","SHIFTS","FLAGS","NORMAL","CAPTURE","BIG_PAWN","EP_CAPTURE","PROMOTION","KSIDE_CASTLE","QSIDE_CASTLE","BITS","SQUARES","a8","b8","c8","d8","e8","f8","g8","h8","a7","b7","c7","d7","e7","f7","g7","h7","a6","b6","c6","d6","e6","f6","g6","h6","a5","b5","c5","d5","e5","f5","g5","h5","a4","b4","c4","d4","e4","f4","g4","h4","a3","b3","c3","d3","e3","f3","g3","h3","a2","b2","c2","d2","e2","f2","g2","a1","b1","c1","d1","e1","f1","g1","ROOKS","square","flag","board","kings","turn","castling","ep_square","half_moves","move_number","history","header","clear","keep_headers","update_setup","generate_fen","reset","load","tokens","split","position","validate_fen","valid","piece","indexOf","color","put","toLowerCase","algebraic","errors","error_number","error","isNaN","sum_fields","previous_was_number","empty","cflags","epflags","set_header","args","sq","build_move","from","to","flags","captured","generate_moves","add_move","rank","pieces","len","us","them","swap_color","second_rank","first_sq","last_sq","single_square","legal","castling_to","castling_from","attacked","legal_moves","make_move","king_attacked","undo_move","move_to_san","sloppy","output","disambiguator","ambiguities","same_rank","same_file","ambig_from","ambig_to","ambig_piece","file","get_disambiguator","in_check","in_checkmate","stripped_san","difference","index","blocked","in_stalemate","insufficient_material","bishops","num_pieces","sq_color","sum","in_threefold_repetition","positions","repetition","pop","old","move_from_san","clean_move","matches","match","f","substring","make_pretty","ugly_move","clone","obj","dupe","san","WHITE","BLACK","PAWN","KNIGHT","BISHOP","ROOK","QUEEN","KING","keys","ugly_moves","verbose","in_draw","game_over","newline","newline_char","max_width","header_exists","reversed_history","move_string","Result","current_width","load_pgn","mask","header_regex","RegExp","header_string","exec","headers","header_obj","parse_pgn_header","ms","rav_regex","half_move","has_keys","arguments","ascii","move_obj","pretty_move","undo","remove","perft","depth","nodes","square_color","sq_0x88","move_history","StringBuilder","that","strings","append","isEmpty","lastChar","Utils","nativeIsArray","isArray","MAX_ARRAY_INDEX","Math","pow","isArrayLike","collection","getLength","pvEach","iteratee","context","func","argCount","accumulator","apply","optimizeCb","pvIsElement","nodeType","pvIsEmpty","isString","isArguments","pgnReader","configuration","utils","pgnFile","url","request","XMLHttpRequest","open","send","status","responseText","readPgnFromFile","assign","locale","initialize_configuration","startMove","set_to_start","PGN_TAGS","event","site","date","round","white","black","eco","whitemyelo","blackmyelo","whitedays","blackdays","mychessno","annotator","plycount","timecontrol","time","termination","setup","PROMOTIONS","NAGs","PGN_NAGS","nag_to_symbol","array","ret_string","number","getFig","mate","prom","_mgame","SetUp","FEN","endGame","interpretHeaders","readMoves","startPlay","hideMovesBefore","new_fen","deleteMovesBefore","new_pgn","write_pgn","movesMainLine","remindEndGame","eachMove","isMove","getMoves","id","isDeleted","current","getMove","updateVariationLevel","varLevel","my_move","variationLevel","undefined","next","deleteMove","removeFromArray","splice","startVariation","vars","prev","variationMove","deleteMovesBeforeIncluding","my_fen","prepend_space","sb","write_comment","comment","write_variation","write_move","write_comment_move","write_move_number","write_comment_before","write_notation","ele","write_NAGs","write_comment_after","has_diags","sbdiags","first","fields","field","arrows","arrow","write_comment_diag","write_variations","get_next_move","indexFirstMove","_sb","write_end_game","eachMoveVariation","moveArray","level","prevMove","findPrevMove","currentMove","wireMoves","pgn_move","getMoveNumberFromPosition","variation","firstMove","getOrderedMoves","returnedMoves","promoteMove","firstMoveOfVariation","myFirst","higherVariationMove","indexVariation","tmpMove","tmpVariations","findMove","moveRep","startsWith","getEndGame","getTags","getParser","startMainLine","endVariation","afterMoveWithVariation","changeNag","added","nagSym","string","symbol_to_nag","clearNags","addMove","existing_first_move","existing_variation_first_move","curr","nextMove","mainMove","existing_move","real_move","get_turn","includes","ep","handle_variation","has_diagram_nag","NAGS","sanWithNags","_san","possibleMoves","dests","map","setShapes","shapes","shape","dest","colArrow","brush","orig","colField","fie"],"mappings":"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","file":"pgn.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"pgn-parser\"] = factory();\n\telse\n\t\troot[\"pgn-parser\"] = factory();\n})(global, function() {\nreturn "," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"/lib/\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 2);\n","/*\n * Generated by PEG.js 0.10.0.\n *\n * http://pegjs.org/\n */\n\n\"use strict\";\n\nfunction peg$subclass(child, parent) {\n  function ctor() { this.constructor = child; }\n  ctor.prototype = parent.prototype;\n  child.prototype = new ctor();\n}\n\nfunction peg$SyntaxError(message, expected, found, location) {\n  this.message  = message;\n  this.expected = expected;\n  this.found    = found;\n  this.location = location;\n  this.name     = \"SyntaxError\";\n\n  if (typeof Error.captureStackTrace === \"function\") {\n    Error.captureStackTrace(this, peg$SyntaxError);\n  }\n}\n\npeg$subclass(peg$SyntaxError, Error);\n\npeg$SyntaxError.buildMessage = function(expected, found) {\n  var DESCRIBE_EXPECTATION_FNS = {\n        literal: function(expectation) {\n          return \"\\\"\" + literalEscape(expectation.text) + \"\\\"\";\n        },\n\n        \"class\": function(expectation) {\n          var escapedParts = \"\",\n              i;\n\n          for (i = 0; i < expectation.parts.length; i++) {\n            escapedParts += expectation.parts[i] instanceof Array\n              ? classEscape(expectation.parts[i][0]) + \"-\" + classEscape(expectation.parts[i][1])\n              : classEscape(expectation.parts[i]);\n          }\n\n          return \"[\" + (expectation.inverted ? \"^\" : \"\") + escapedParts + \"]\";\n        },\n\n        any: function(expectation) {\n          return \"any character\";\n        },\n\n        end: function(expectation) {\n          return \"end of input\";\n        },\n\n        other: function(expectation) {\n          return expectation.description;\n        }\n      };\n\n  function hex(ch) {\n    return ch.charCodeAt(0).toString(16).toUpperCase();\n  }\n\n  function literalEscape(s) {\n    return s\n      .replace(/\\\\/g, '\\\\\\\\')\n      .replace(/\"/g,  '\\\\\"')\n      .replace(/\\0/g, '\\\\0')\n      .replace(/\\t/g, '\\\\t')\n      .replace(/\\n/g, '\\\\n')\n      .replace(/\\r/g, '\\\\r')\n      .replace(/[\\x00-\\x0F]/g,          function(ch) { return '\\\\x0' + hex(ch); })\n      .replace(/[\\x10-\\x1F\\x7F-\\x9F]/g, function(ch) { return '\\\\x'  + hex(ch); });\n  }\n\n  function classEscape(s) {\n    return s\n      .replace(/\\\\/g, '\\\\\\\\')\n      .replace(/\\]/g, '\\\\]')\n      .replace(/\\^/g, '\\\\^')\n      .replace(/-/g,  '\\\\-')\n      .replace(/\\0/g, '\\\\0')\n      .replace(/\\t/g, '\\\\t')\n      .replace(/\\n/g, '\\\\n')\n      .replace(/\\r/g, '\\\\r')\n      .replace(/[\\x00-\\x0F]/g,          function(ch) { return '\\\\x0' + hex(ch); })\n      .replace(/[\\x10-\\x1F\\x7F-\\x9F]/g, function(ch) { return '\\\\x'  + hex(ch); });\n  }\n\n  function describeExpectation(expectation) {\n    return DESCRIBE_EXPECTATION_FNS[expectation.type](expectation);\n  }\n\n  function describeExpected(expected) {\n    var descriptions = new Array(expected.length),\n        i, j;\n\n    for (i = 0; i < expected.length; i++) {\n      descriptions[i] = describeExpectation(expected[i]);\n    }\n\n    descriptions.sort();\n\n    if (descriptions.length > 0) {\n      for (i = 1, j = 1; i < descriptions.length; i++) {\n        if (descriptions[i - 1] !== descriptions[i]) {\n          descriptions[j] = descriptions[i];\n          j++;\n        }\n      }\n      descriptions.length = j;\n    }\n\n    switch (descriptions.length) {\n      case 1:\n        return descriptions[0];\n\n      case 2:\n        return descriptions[0] + \" or \" + descriptions[1];\n\n      default:\n        return descriptions.slice(0, -1).join(\", \")\n          + \", or \"\n          + descriptions[descriptions.length - 1];\n    }\n  }\n\n  function describeFound(found) {\n    return found ? \"\\\"\" + literalEscape(found) + \"\\\"\" : \"end of input\";\n  }\n\n  return \"Expected \" + describeExpected(expected) + \" but \" + describeFound(found) + \" found.\";\n};\n\nfunction peg$parse(input, options) {\n  options = options !== void 0 ? options : {};\n\n  var peg$FAILED = {},\n\n      peg$startRuleFunctions = { pgn: peg$parsepgn, tags: peg$parsetags, game: peg$parsegame },\n      peg$startRuleFunction  = peg$parsepgn,\n\n      peg$c0 = function(t, p) { return { tags: t, moves: p[0] }; },\n      peg$c1 = function(head, m) { return m; },\n      peg$c2 = function(head, tail) {\n              var result = {};\n              [head].concat(tail).forEach(function(element) {\n                result[element.name] = element.value;\n              });\n              return result;\n            },\n      peg$c3 = function(members) { return members !== null ? members: {}; },\n      peg$c4 = function(tag) { return tag; },\n      peg$c5 = function(value) { return { name: 'Event', value: value }; },\n      peg$c6 = function(value) { return { name: 'Site', value: value }; },\n      peg$c7 = function(value) { return { name: 'Date', value: value }; },\n      peg$c8 = function(value) { return { name: 'Round', value: value }; },\n      peg$c9 = function(value) { return { name: 'White', value: value }; },\n      peg$c10 = function(value) { return { name: 'Black', value: value }; },\n      peg$c11 = function(value) { return { name: 'Result', value: value }; },\n      peg$c12 = function(value) { return { name: 'WhiteTitle', value: value }; },\n      peg$c13 = function(value) { return { name: 'BlackTitle', value: value }; },\n      peg$c14 = function(value) { return { name: 'WhiteELO', value: value }; },\n      peg$c15 = function(value) { return { name: 'BlackELO', value: value }; },\n      peg$c16 = function(value) { return { name: 'WhiteUSCF', value: value }; },\n      peg$c17 = function(value) { return { name: 'BlackUSCF', value: value }; },\n      peg$c18 = function(value) { return { name: 'WhiteNA', value: value }; },\n      peg$c19 = function(value) { return { name: 'BlackNA', value: value }; },\n      peg$c20 = function(value) { return { name: 'WhiteType', value: value }; },\n      peg$c21 = function(value) { return { name: 'BlackType', value: value }; },\n      peg$c22 = function(value) { return { name: 'EventDate', value: value }; },\n      peg$c23 = function(value) { return { name: 'EventSponsor', value: value }; },\n      peg$c24 = function(value) { return { name: 'Section', value: value }; },\n      peg$c25 = function(value) { return { name: 'Stage', value: value }; },\n      peg$c26 = function(value) { return { name: 'Board', value: value }; },\n      peg$c27 = function(value) { return { name: 'Opening', value: value }; },\n      peg$c28 = function(value) { return { name: 'Variation', value: value }; },\n      peg$c29 = function(value) { return { name: 'SubVariation', value: value }; },\n      peg$c30 = function(value) { return { name: 'ECO', value: value }; },\n      peg$c31 = function(value) { return { name: 'NIC', value: value }; },\n      peg$c32 = function(value) { return { name: 'Time', value: value }; },\n      peg$c33 = function(value) { return { name: 'UTCTime', value: value }; },\n      peg$c34 = function(value) { return { name: 'UTCDate', value: value }; },\n      peg$c35 = function(value) { return { name: 'TimeControl', value: value }; },\n      peg$c36 = function(value) { return { name: 'SetUp', value: value }; },\n      peg$c37 = function(value) { return { name: 'FEN', value: value }; },\n      peg$c38 = function(value) { return { name: 'Termination', value: value }; },\n      peg$c39 = function(value) { return { name: 'Annotator', value: value }; },\n      peg$c40 = function(value) { return { name: 'Mode', value: value }; },\n      peg$c41 = function(value) { return { name: 'PlyCount', value: value }; },\n      peg$c42 = \"Event\",\n      peg$c43 = peg$literalExpectation(\"Event\", false),\n      peg$c44 = \"Site\",\n      peg$c45 = peg$literalExpectation(\"Site\", false),\n      peg$c46 = \"Date\",\n      peg$c47 = peg$literalExpectation(\"Date\", false),\n      peg$c48 = \"Round\",\n      peg$c49 = peg$literalExpectation(\"Round\", false),\n      peg$c50 = \"White\",\n      peg$c51 = peg$literalExpectation(\"White\", false),\n      peg$c52 = \"Black\",\n      peg$c53 = peg$literalExpectation(\"Black\", false),\n      peg$c54 = \"Result\",\n      peg$c55 = peg$literalExpectation(\"Result\", false),\n      peg$c56 = \"WhiteTitle\",\n      peg$c57 = peg$literalExpectation(\"WhiteTitle\", false),\n      peg$c58 = \"BlackTitle\",\n      peg$c59 = peg$literalExpectation(\"BlackTitle\", false),\n      peg$c60 = \"WhiteELO\",\n      peg$c61 = peg$literalExpectation(\"WhiteELO\", false),\n      peg$c62 = \"BlackELO\",\n      peg$c63 = peg$literalExpectation(\"BlackELO\", false),\n      peg$c64 = \"WhiteUSCF\",\n      peg$c65 = peg$literalExpectation(\"WhiteUSCF\", false),\n      peg$c66 = \"BlackUSCF\",\n      peg$c67 = peg$literalExpectation(\"BlackUSCF\", false),\n      peg$c68 = \"WhiteNA\",\n      peg$c69 = peg$literalExpectation(\"WhiteNA\", false),\n      peg$c70 = \"BlackNA\",\n      peg$c71 = peg$literalExpectation(\"BlackNA\", false),\n      peg$c72 = \"WhiteType\",\n      peg$c73 = peg$literalExpectation(\"WhiteType\", false),\n      peg$c74 = \"BlackType\",\n      peg$c75 = peg$literalExpectation(\"BlackType\", false),\n      peg$c76 = \"EventDate\",\n      peg$c77 = peg$literalExpectation(\"EventDate\", false),\n      peg$c78 = \"EventSponsor\",\n      peg$c79 = peg$literalExpectation(\"EventSponsor\", false),\n      peg$c80 = \"Section\",\n      peg$c81 = peg$literalExpectation(\"Section\", false),\n      peg$c82 = \"Stage\",\n      peg$c83 = peg$literalExpectation(\"Stage\", false),\n      peg$c84 = \"Board\",\n      peg$c85 = peg$literalExpectation(\"Board\", false),\n      peg$c86 = \"Opening\",\n      peg$c87 = peg$literalExpectation(\"Opening\", false),\n      peg$c88 = \"Variation\",\n      peg$c89 = peg$literalExpectation(\"Variation\", false),\n      peg$c90 = \"SubVariation\",\n      peg$c91 = peg$literalExpectation(\"SubVariation\", false),\n      peg$c92 = \"ECO\",\n      peg$c93 = peg$literalExpectation(\"ECO\", false),\n      peg$c94 = \"NIC\",\n      peg$c95 = peg$literalExpectation(\"NIC\", false),\n      peg$c96 = \"Time\",\n      peg$c97 = peg$literalExpectation(\"Time\", false),\n      peg$c98 = \"UTCTime\",\n      peg$c99 = peg$literalExpectation(\"UTCTime\", false),\n      peg$c100 = \"UTCDate\",\n      peg$c101 = peg$literalExpectation(\"UTCDate\", false),\n      peg$c102 = \"TimeControl\",\n      peg$c103 = peg$literalExpectation(\"TimeControl\", false),\n      peg$c104 = \"SetUp\",\n      peg$c105 = peg$literalExpectation(\"SetUp\", false),\n      peg$c106 = \"FEN\",\n      peg$c107 = peg$literalExpectation(\"FEN\", false),\n      peg$c108 = \"Termination\",\n      peg$c109 = peg$literalExpectation(\"Termination\", false),\n      peg$c110 = \"Annotator\",\n      peg$c111 = peg$literalExpectation(\"Annotator\", false),\n      peg$c112 = \"Mode\",\n      peg$c113 = peg$literalExpectation(\"Mode\", false),\n      peg$c114 = \"PlyCount\",\n      peg$c115 = peg$literalExpectation(\"PlyCount\", false),\n      peg$c116 = peg$otherExpectation(\"whitespace\"),\n      peg$c117 = /^[ \\t\\n\\r]/,\n      peg$c118 = peg$classExpectation([\" \", \"\\t\", \"\\n\", \"\\r\"], false, false),\n      peg$c119 = peg$otherExpectation(\"string\"),\n      peg$c120 = function(chars) { return chars.join(\"\"); },\n      peg$c121 = \"\\\"\",\n      peg$c122 = peg$literalExpectation(\"\\\"\", false),\n      peg$c123 = /^[^\\0-\\x1F\"\\\\]/,\n      peg$c124 = peg$classExpectation([[\"\\0\", \"\\x1F\"], \"\\\"\", \"\\\\\"], true, false),\n      peg$c125 = /^[0-9]/,\n      peg$c126 = peg$classExpectation([[\"0\", \"9\"]], false, false),\n      peg$c127 = \".\",\n      peg$c128 = peg$literalExpectation(\".\", false),\n      peg$c129 = function(year, month, day) { return \"\" + year.join(\"\") + '.' + month.join(\"\") + '.' + day.join(\"\");},\n      peg$c130 = function(res) { return res; },\n      peg$c131 = \"1-0\",\n      peg$c132 = peg$literalExpectation(\"1-0\", false),\n      peg$c133 = function(res) {return res; },\n      peg$c134 = \"1:0\",\n      peg$c135 = peg$literalExpectation(\"1:0\", false),\n      peg$c136 = \"0-1\",\n      peg$c137 = peg$literalExpectation(\"0-1\", false),\n      peg$c138 = \"0:1\",\n      peg$c139 = peg$literalExpectation(\"0:1\", false),\n      peg$c140 = \"1/2-1/2\",\n      peg$c141 = peg$literalExpectation(\"1/2-1/2\", false),\n      peg$c142 = \"*\",\n      peg$c143 = peg$literalExpectation(\"*\", false),\n      peg$c144 = \"-\",\n      peg$c145 = peg$literalExpectation(\"-\", false),\n      peg$c146 = function(digits) { return makeInteger(digits); },\n      peg$c147 = function(pw, all) { var arr = (all ? all : []); arr.unshift(pw);return arr; },\n      peg$c148 = function(pb, all) { var arr = (all ? all : []); arr.unshift(pb); return arr; },\n      peg$c149 = function() { return [[]]; },\n      peg$c150 = function(pw) { return pw; },\n      peg$c151 = function(pb) { return pb; },\n      peg$c152 = function(cm, mn, cb, hm, nag, ca, cd, vari, all) { var arr = (all ? all : []);\n            var move = {}; move.turn = 'w'; move.moveNumber = mn;\n            move.notation = hm; move.commentBefore = cb; move.commentAfter = ca; move.commentMove = cm;\n            move.variations = (vari ? vari : []); move.nag = (nag ? nag : null); arr.unshift(move); \n            move.commentDiag = cd;\n            return arr; },\n      peg$c153 = function(cm, me, cb, hm, nag, ca, cd, vari, all) { var arr = (all ? all : []);\n            var move = {}; move.turn = 'b'; move.moveNumber = me;\n            move.notation = hm; move.commentBefore = cb; move.commentAfter = ca; move.commentMove = cm;\n            move.variations = (vari ? vari : []); arr.unshift(move); move.nag = (nag ? nag : null);\n            move.commentDiag = cd;\n            return arr; },\n      peg$c154 = function() { return [\"1:0\"]; },\n      peg$c155 = function() { return [\"0:1\"]; },\n      peg$c156 = function() { return [\"1-0\"]; },\n      peg$c157 = function() { return [\"0-1\"]; },\n      peg$c158 = function() { return [\"1/2-1/2\"]; },\n      peg$c159 = function() { return [\"*\"]; },\n      peg$c160 = function(cf, cfl) { var comm = cf; for (var i=0; i < cfl.length; i++) { comm += \" \" + cfl[i][1]}; return comm; },\n      peg$c161 = /^[^}]/,\n      peg$c162 = peg$classExpectation([\"}\"], true, false),\n      peg$c163 = function(cm) { return cm.join(\"\").trim(); },\n      peg$c164 = function(cas) { return cas; },\n      peg$c165 = function(ca, cal) { var ret = { }; if (cal) { var o = cal[0]; return {...ca, ...o}; } return ca; },\n      peg$c166 = function(caf) { var ret = {}; ret.colorFields = caf; return ret; },\n      peg$c167 = function(caa) { var ret = {}; ret.colorArrows = caa; return ret; },\n      peg$c168 = function(cac) { var ret = {}; ret.clock = cac; return ret; },\n      peg$c169 = \"%csl\",\n      peg$c170 = peg$literalExpectation(\"%csl\", false),\n      peg$c171 = function(cfs) { return cfs; },\n      peg$c172 = \"%cal\",\n      peg$c173 = peg$literalExpectation(\"%cal\", false),\n      peg$c174 = \",\",\n      peg$c175 = peg$literalExpectation(\",\", false),\n      peg$c176 = function(cf, cfl) { var arr = []; arr.push(cf); for (var i=0; i < cfl.length; i++) { arr.push(cfl[i][2])}; return arr; },\n      peg$c177 = function(col, f) { return col + f; },\n      peg$c178 = function(col, ff, ft) { return col + ff + ft; },\n      peg$c179 = \"Y\",\n      peg$c180 = peg$literalExpectation(\"Y\", false),\n      peg$c181 = function() { return \"Y\"; },\n      peg$c182 = \"G\",\n      peg$c183 = peg$literalExpectation(\"G\", false),\n      peg$c184 = function() { return \"G\"; },\n      peg$c185 = \"R\",\n      peg$c186 = peg$literalExpectation(\"R\", false),\n      peg$c187 = function() { return \"R\"; },\n      peg$c188 = \"B\",\n      peg$c189 = peg$literalExpectation(\"B\", false),\n      peg$c190 = function() { return \"B\"; },\n      peg$c191 = function(col, row) { return col + row; },\n      peg$c192 = \"{\",\n      peg$c193 = peg$literalExpectation(\"{\", false),\n      peg$c194 = \"}\",\n      peg$c195 = peg$literalExpectation(\"}\", false),\n      peg$c196 = \"[\",\n      peg$c197 = peg$literalExpectation(\"[\", false),\n      peg$c198 = \"]\",\n      peg$c199 = peg$literalExpectation(\"]\", false),\n      peg$c200 = \"%\",\n      peg$c201 = peg$literalExpectation(\"%\", false),\n      peg$c202 = function(cc, cv) { var ret = {}; ret.type = cc; ret.value = cv; return ret; },\n      peg$c203 = \"clk\",\n      peg$c204 = peg$literalExpectation(\"clk\", false),\n      peg$c205 = function() { return \"clk\"; },\n      peg$c206 = \"egt\",\n      peg$c207 = peg$literalExpectation(\"egt\", false),\n      peg$c208 = function() { return \"egt\"; },\n      peg$c209 = \"emt\",\n      peg$c210 = peg$literalExpectation(\"emt\", false),\n      peg$c211 = function() { return \"emt\"; },\n      peg$c212 = \"mct\",\n      peg$c213 = peg$literalExpectation(\"mct\", false),\n      peg$c214 = function() { return \"mct\"; },\n      peg$c215 = \":\",\n      peg$c216 = peg$literalExpectation(\":\", false),\n      peg$c217 = function(h1, h2, m1, m2, s1, s2) { var ret = h1; if (h2) { ret += h2 }; ret += \":\" + m1 + m2 + \":\" + s1 + s2; return ret; },\n      peg$c218 = function(d) { return d; },\n      peg$c219 = function(vari, all, me) { var arr = (all ? all : []); arr.unshift(vari); return arr; },\n      peg$c220 = function(vari, all) { var arr = (all ? all : []); arr.unshift(vari); return arr; },\n      peg$c221 = \"(\",\n      peg$c222 = peg$literalExpectation(\"(\", false),\n      peg$c223 = \")\",\n      peg$c224 = peg$literalExpectation(\")\", false),\n      peg$c225 = function(num) { return num; },\n      peg$c226 = peg$otherExpectation(\"integer\"),\n      peg$c227 = \" \",\n      peg$c228 = peg$literalExpectation(\" \", false),\n      peg$c229 = function() { return '';},\n      peg$c230 = function(fig, disc, str, col, row, pr, ch) { var hm = {}; hm.fig = (fig ? fig : null); hm.disc =  (disc ? disc : null); hm.strike = (str ? str : null); hm.col = col; hm.row = row; hm.check = (ch ? ch : null); hm.promotion = pr; hm.notation = (fig ? fig : \"\") + (disc ? disc : \"\") + (str ? str : \"\") + col + row + (pr ? pr : \"\") + (ch ? ch : \"\"); return hm; },\n      peg$c231 = function(fig, cols, rows, str, col, row, pr, ch) { var hm = {}; hm.fig = (fig ? fig : null); hm.strike = (str =='x' ? str : null); hm.col = col; hm.row = row; hm.check = (ch ? ch : null); hm.notation = (fig && (fig!=='P') ? fig : \"\") + cols + rows + (str=='x' ? str : \"-\") + col  + row + (pr ? pr : \"\") + (ch ? ch : \"\"); hm.promotion = pr; return hm; },\n      peg$c232 = function(fig, str, col, row, pr, ch) { var hm = {}; hm.fig = (fig ? fig : null); hm.strike = (str ? str : null); hm.col = col; hm.row = row; hm.check = (ch ? ch : null); hm.notation = (fig ? fig : \"\") + (str ? str : \"\") + col  + row + (pr ? pr : \"\") + (ch ? ch : \"\"); hm.promotion = pr; return hm; },\n      peg$c233 = \"O-O-O\",\n      peg$c234 = peg$literalExpectation(\"O-O-O\", false),\n      peg$c235 = function(ch) { var hm = {}; hm.notation = 'O-O-O'+ (ch ? ch : \"\"); hm.check = (ch ? ch : null); return  hm; },\n      peg$c236 = \"O-O\",\n      peg$c237 = peg$literalExpectation(\"O-O\", false),\n      peg$c238 = function(ch) { var hm = {}; hm.notation = 'O-O'+ (ch ? ch : \"\"); hm.check = (ch ? ch : null); return  hm; },\n      peg$c239 = \"+-\",\n      peg$c240 = peg$literalExpectation(\"+-\", false),\n      peg$c241 = \"+\",\n      peg$c242 = peg$literalExpectation(\"+\", false),\n      peg$c243 = function(ch) { return ch[1]; },\n      peg$c244 = \"$$$\",\n      peg$c245 = peg$literalExpectation(\"$$$\", false),\n      peg$c246 = \"#\",\n      peg$c247 = peg$literalExpectation(\"#\", false),\n      peg$c248 = \"=\",\n      peg$c249 = peg$literalExpectation(\"=\", false),\n      peg$c250 = function(f) { return '=' + f; },\n      peg$c251 = function(nag, nags) { var arr = (nags ? nags : []); arr.unshift(nag); return arr; },\n      peg$c252 = \"$\",\n      peg$c253 = peg$literalExpectation(\"$\", false),\n      peg$c254 = function(num) { return '$' + num; },\n      peg$c255 = \"!!\",\n      peg$c256 = peg$literalExpectation(\"!!\", false),\n      peg$c257 = function() { return '$3'; },\n      peg$c258 = \"??\",\n      peg$c259 = peg$literalExpectation(\"??\", false),\n      peg$c260 = function() { return '$4'; },\n      peg$c261 = \"!?\",\n      peg$c262 = peg$literalExpectation(\"!?\", false),\n      peg$c263 = function() { return '$5'; },\n      peg$c264 = \"?!\",\n      peg$c265 = peg$literalExpectation(\"?!\", false),\n      peg$c266 = function() { return '$6'; },\n      peg$c267 = \"!\",\n      peg$c268 = peg$literalExpectation(\"!\", false),\n      peg$c269 = function() { return '$1'; },\n      peg$c270 = \"?\",\n      peg$c271 = peg$literalExpectation(\"?\", false),\n      peg$c272 = function() { return '$2'; },\n      peg$c273 = \"\\u203C\",\n      peg$c274 = peg$literalExpectation(\"\\u203C\", false),\n      peg$c275 = \"\\u2047\",\n      peg$c276 = peg$literalExpectation(\"\\u2047\", false),\n      peg$c277 = \"\\u2049\",\n      peg$c278 = peg$literalExpectation(\"\\u2049\", false),\n      peg$c279 = \"\\u2048\",\n      peg$c280 = peg$literalExpectation(\"\\u2048\", false),\n      peg$c281 = \"\\u25A1\",\n      peg$c282 = peg$literalExpectation(\"\\u25A1\", false),\n      peg$c283 = function() { return '$7'; },\n      peg$c284 = function() { return '$10'; },\n      peg$c285 = \"\\u221E\",\n      peg$c286 = peg$literalExpectation(\"\\u221E\", false),\n      peg$c287 = function() { return '$13'; },\n      peg$c288 = \"\\u2A72\",\n      peg$c289 = peg$literalExpectation(\"\\u2A72\", false),\n      peg$c290 = function() { return '$14'; },\n      peg$c291 = \"\\u2A71\",\n      peg$c292 = peg$literalExpectation(\"\\u2A71\", false),\n      peg$c293 = function() { return '$15';},\n      peg$c294 = \"\\xB1\",\n      peg$c295 = peg$literalExpectation(\"\\xB1\", false),\n      peg$c296 = function() { return '$16';},\n      peg$c297 = \"\\u2213\",\n      peg$c298 = peg$literalExpectation(\"\\u2213\", false),\n      peg$c299 = function() { return '$17';},\n      peg$c300 = function() { return '$18';},\n      peg$c301 = \"-+\",\n      peg$c302 = peg$literalExpectation(\"-+\", false),\n      peg$c303 = function() { return '$19';},\n      peg$c304 = \"\\u2A00\",\n      peg$c305 = peg$literalExpectation(\"\\u2A00\", false),\n      peg$c306 = function() { return '$22'; },\n      peg$c307 = \"\\u27F3\",\n      peg$c308 = peg$literalExpectation(\"\\u27F3\", false),\n      peg$c309 = function() { return '$32'; },\n      peg$c310 = \"\\u2192\",\n      peg$c311 = peg$literalExpectation(\"\\u2192\", false),\n      peg$c312 = function() { return '$36'; },\n      peg$c313 = \"\\u2191\",\n      peg$c314 = peg$literalExpectation(\"\\u2191\", false),\n      peg$c315 = function() { return '$40'; },\n      peg$c316 = \"\\u21C6\",\n      peg$c317 = peg$literalExpectation(\"\\u21C6\", false),\n      peg$c318 = function() { return '$132'; },\n      peg$c319 = \"D\",\n      peg$c320 = peg$literalExpectation(\"D\", false),\n      peg$c321 = function() { return '$220'; },\n      peg$c322 = /^[RNBQKP]/,\n      peg$c323 = peg$classExpectation([\"R\", \"N\", \"B\", \"Q\", \"K\", \"P\"], false, false),\n      peg$c324 = /^[RNBQ]/,\n      peg$c325 = peg$classExpectation([\"R\", \"N\", \"B\", \"Q\"], false, false),\n      peg$c326 = /^[a-h]/,\n      peg$c327 = peg$classExpectation([[\"a\", \"h\"]], false, false),\n      peg$c328 = /^[1-8]/,\n      peg$c329 = peg$classExpectation([[\"1\", \"8\"]], false, false),\n      peg$c330 = \"x\",\n      peg$c331 = peg$literalExpectation(\"x\", false),\n\n      peg$currPos          = 0,\n      peg$savedPos         = 0,\n      peg$posDetailsCache  = [{ line: 1, column: 1 }],\n      peg$maxFailPos       = 0,\n      peg$maxFailExpected  = [],\n      peg$silentFails      = 0,\n\n      peg$result;\n\n  if (\"startRule\" in options) {\n    if (!(options.startRule in peg$startRuleFunctions)) {\n      throw new Error(\"Can't start parsing from rule \\\"\" + options.startRule + \"\\\".\");\n    }\n\n    peg$startRuleFunction = peg$startRuleFunctions[options.startRule];\n  }\n\n  function text() {\n    return input.substring(peg$savedPos, peg$currPos);\n  }\n\n  function location() {\n    return peg$computeLocation(peg$savedPos, peg$currPos);\n  }\n\n  function expected(description, location) {\n    location = location !== void 0 ? location : peg$computeLocation(peg$savedPos, peg$currPos)\n\n    throw peg$buildStructuredError(\n      [peg$otherExpectation(description)],\n      input.substring(peg$savedPos, peg$currPos),\n      location\n    );\n  }\n\n  function error(message, location) {\n    location = location !== void 0 ? location : peg$computeLocation(peg$savedPos, peg$currPos)\n\n    throw peg$buildSimpleError(message, location);\n  }\n\n  function peg$literalExpectation(text, ignoreCase) {\n    return { type: \"literal\", text: text, ignoreCase: ignoreCase };\n  }\n\n  function peg$classExpectation(parts, inverted, ignoreCase) {\n    return { type: \"class\", parts: parts, inverted: inverted, ignoreCase: ignoreCase };\n  }\n\n  function peg$anyExpectation() {\n    return { type: \"any\" };\n  }\n\n  function peg$endExpectation() {\n    return { type: \"end\" };\n  }\n\n  function peg$otherExpectation(description) {\n    return { type: \"other\", description: description };\n  }\n\n  function peg$computePosDetails(pos) {\n    var details = peg$posDetailsCache[pos], p;\n\n    if (details) {\n      return details;\n    } else {\n      p = pos - 1;\n      while (!peg$posDetailsCache[p]) {\n        p--;\n      }\n\n      details = peg$posDetailsCache[p];\n      details = {\n        line:   details.line,\n        column: details.column\n      };\n\n      while (p < pos) {\n        if (input.charCodeAt(p) === 10) {\n          details.line++;\n          details.column = 1;\n        } else {\n          details.column++;\n        }\n\n        p++;\n      }\n\n      peg$posDetailsCache[pos] = details;\n      return details;\n    }\n  }\n\n  function peg$computeLocation(startPos, endPos) {\n    var startPosDetails = peg$computePosDetails(startPos),\n        endPosDetails   = peg$computePosDetails(endPos);\n\n    return {\n      start: {\n        offset: startPos,\n        line:   startPosDetails.line,\n        column: startPosDetails.column\n      },\n      end: {\n        offset: endPos,\n        line:   endPosDetails.line,\n        column: endPosDetails.column\n      }\n    };\n  }\n\n  function peg$fail(expected) {\n    if (peg$currPos < peg$maxFailPos) { return; }\n\n    if (peg$currPos > peg$maxFailPos) {\n      peg$maxFailPos = peg$currPos;\n      peg$maxFailExpected = [];\n    }\n\n    peg$maxFailExpected.push(expected);\n  }\n\n  function peg$buildSimpleError(message, location) {\n    return new peg$SyntaxError(message, null, null, location);\n  }\n\n  function peg$buildStructuredError(expected, found, location) {\n    return new peg$SyntaxError(\n      peg$SyntaxError.buildMessage(expected, found),\n      expected,\n      found,\n      location\n    );\n  }\n\n  function peg$parsegame() {\n    var s0, s1, s2;\n\n    s0 = peg$currPos;\n    s1 = peg$parsetags();\n    if (s1 === peg$FAILED) {\n      s1 = null;\n    }\n    if (s1 !== peg$FAILED) {\n      s2 = peg$parsepgn();\n      if (s2 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s1 = peg$c0(s1, s2);\n        s0 = s1;\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parsetags() {\n    var s0, s1, s2, s3, s4, s5, s6, s7;\n\n    s0 = peg$currPos;\n    s1 = peg$parsews();\n    if (s1 !== peg$FAILED) {\n      s2 = peg$currPos;\n      s3 = peg$parsetag();\n      if (s3 !== peg$FAILED) {\n        s4 = [];\n        s5 = peg$currPos;\n        s6 = peg$parsews();\n        if (s6 !== peg$FAILED) {\n          s7 = peg$parsetag();\n          if (s7 !== peg$FAILED) {\n            peg$savedPos = s5;\n            s6 = peg$c1(s3, s7);\n            s5 = s6;\n          } else {\n            peg$currPos = s5;\n            s5 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s5;\n          s5 = peg$FAILED;\n        }\n        while (s5 !== peg$FAILED) {\n          s4.push(s5);\n          s5 = peg$currPos;\n          s6 = peg$parsews();\n          if (s6 !== peg$FAILED) {\n            s7 = peg$parsetag();\n            if (s7 !== peg$FAILED) {\n              peg$savedPos = s5;\n              s6 = peg$c1(s3, s7);\n              s5 = s6;\n            } else {\n              peg$currPos = s5;\n              s5 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s5;\n            s5 = peg$FAILED;\n          }\n        }\n        if (s4 !== peg$FAILED) {\n          peg$savedPos = s2;\n          s3 = peg$c2(s3, s4);\n          s2 = s3;\n        } else {\n          peg$currPos = s2;\n          s2 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s2;\n        s2 = peg$FAILED;\n      }\n      if (s2 === peg$FAILED) {\n        s2 = null;\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parsews();\n        if (s3 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s1 = peg$c3(s2);\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parsetag() {\n    var s0, s1, s2, s3;\n\n    s0 = peg$currPos;\n    s1 = peg$parsebl();\n    if (s1 !== peg$FAILED) {\n      s2 = peg$parsetagKeyValue();\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parsebr();\n        if (s3 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s1 = peg$c4(s2);\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parsetagKeyValue() {\n    var s0, s1, s2, s3;\n\n    s0 = peg$currPos;\n    s1 = peg$parseeventKey();\n    if (s1 !== peg$FAILED) {\n      s2 = peg$parsews();\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parsestring();\n        if (s3 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s1 = peg$c5(s3);\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n    if (s0 === peg$FAILED) {\n      s0 = peg$currPos;\n      s1 = peg$parsesiteKey();\n      if (s1 !== peg$FAILED) {\n        s2 = peg$parsews();\n        if (s2 !== peg$FAILED) {\n          s3 = peg$parsestring();\n          if (s3 !== peg$FAILED) {\n            peg$savedPos = s0;\n            s1 = peg$c6(s3);\n            s0 = s1;\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n      if (s0 === peg$FAILED) {\n        s0 = peg$currPos;\n        s1 = peg$parsedateKey();\n        if (s1 !== peg$FAILED) {\n          s2 = peg$parsews();\n          if (s2 !== peg$FAILED) {\n            s3 = peg$parsedate();\n            if (s3 !== peg$FAILED) {\n              peg$savedPos = s0;\n              s1 = peg$c7(s3);\n              s0 = s1;\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n        if (s0 === peg$FAILED) {\n          s0 = peg$currPos;\n          s1 = peg$parseroundKey();\n          if (s1 !== peg$FAILED) {\n            s2 = peg$parsews();\n            if (s2 !== peg$FAILED) {\n              s3 = peg$parsestring();\n              if (s3 !== peg$FAILED) {\n                peg$savedPos = s0;\n                s1 = peg$c8(s3);\n                s0 = s1;\n              } else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n          if (s0 === peg$FAILED) {\n            s0 = peg$currPos;\n            s1 = peg$parsewhiteKey();\n            if (s1 !== peg$FAILED) {\n              s2 = peg$parsews();\n              if (s2 !== peg$FAILED) {\n                s3 = peg$parsestring();\n                if (s3 !== peg$FAILED) {\n                  peg$savedPos = s0;\n                  s1 = peg$c9(s3);\n                  s0 = s1;\n                } else {\n                  peg$currPos = s0;\n                  s0 = peg$FAILED;\n                }\n              } else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n            if (s0 === peg$FAILED) {\n              s0 = peg$currPos;\n              s1 = peg$parseblackKey();\n              if (s1 !== peg$FAILED) {\n                s2 = peg$parsews();\n                if (s2 !== peg$FAILED) {\n                  s3 = peg$parsestring();\n                  if (s3 !== peg$FAILED) {\n                    peg$savedPos = s0;\n                    s1 = peg$c10(s3);\n                    s0 = s1;\n                  } else {\n                    peg$currPos = s0;\n                    s0 = peg$FAILED;\n                  }\n                } else {\n                  peg$currPos = s0;\n                  s0 = peg$FAILED;\n                }\n              } else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n              }\n              if (s0 === peg$FAILED) {\n                s0 = peg$currPos;\n                s1 = peg$parseresultKey();\n                if (s1 !== peg$FAILED) {\n                  s2 = peg$parsews();\n                  if (s2 !== peg$FAILED) {\n                    s3 = peg$parseresult();\n                    if (s3 !== peg$FAILED) {\n                      peg$savedPos = s0;\n                      s1 = peg$c11(s3);\n                      s0 = s1;\n                    } else {\n                      peg$currPos = s0;\n                      s0 = peg$FAILED;\n                    }\n                  } else {\n                    peg$currPos = s0;\n                    s0 = peg$FAILED;\n                  }\n                } else {\n                  peg$currPos = s0;\n                  s0 = peg$FAILED;\n                }\n                if (s0 === peg$FAILED) {\n                  s0 = peg$currPos;\n                  s1 = peg$parsewhiteTitleKey();\n                  if (s1 !== peg$FAILED) {\n                    s2 = peg$parsews();\n                    if (s2 !== peg$FAILED) {\n                      s3 = peg$parsestring();\n                      if (s3 !== peg$FAILED) {\n                        peg$savedPos = s0;\n                        s1 = peg$c12(s3);\n                        s0 = s1;\n                      } else {\n                        peg$currPos = s0;\n                        s0 = peg$FAILED;\n                      }\n                    } else {\n                      peg$currPos = s0;\n                      s0 = peg$FAILED;\n                    }\n                  } else {\n                    peg$currPos = s0;\n                    s0 = peg$FAILED;\n                  }\n                  if (s0 === peg$FAILED) {\n                    s0 = peg$currPos;\n                    s1 = peg$parseblackTitleKey();\n                    if (s1 !== peg$FAILED) {\n                      s2 = peg$parsews();\n                      if (s2 !== peg$FAILED) {\n                        s3 = peg$parsestring();\n                        if (s3 !== peg$FAILED) {\n                          peg$savedPos = s0;\n                          s1 = peg$c13(s3);\n                          s0 = s1;\n                        } else {\n                          peg$currPos = s0;\n                          s0 = peg$FAILED;\n                        }\n                      } else {\n                        peg$currPos = s0;\n                        s0 = peg$FAILED;\n                      }\n                    } else {\n                      peg$currPos = s0;\n                      s0 = peg$FAILED;\n                    }\n                    if (s0 === peg$FAILED) {\n                      s0 = peg$currPos;\n                      s1 = peg$parsewhiteEloKey();\n                      if (s1 !== peg$FAILED) {\n                        s2 = peg$parsews();\n                        if (s2 !== peg$FAILED) {\n                          s3 = peg$parseintegerOrDash();\n                          if (s3 !== peg$FAILED) {\n                            peg$savedPos = s0;\n                            s1 = peg$c14(s3);\n                            s0 = s1;\n                          } else {\n                            peg$currPos = s0;\n                            s0 = peg$FAILED;\n                          }\n                        } else {\n                          peg$currPos = s0;\n                          s0 = peg$FAILED;\n                        }\n                      } else {\n                        peg$currPos = s0;\n                        s0 = peg$FAILED;\n                      }\n                      if (s0 === peg$FAILED) {\n                        s0 = peg$currPos;\n                        s1 = peg$parseblackEloKey();\n                        if (s1 !== peg$FAILED) {\n                          s2 = peg$parsews();\n                          if (s2 !== peg$FAILED) {\n                            s3 = peg$parseintegerOrDash();\n                            if (s3 !== peg$FAILED) {\n                              peg$savedPos = s0;\n                              s1 = peg$c15(s3);\n                              s0 = s1;\n                            } else {\n                              peg$currPos = s0;\n                              s0 = peg$FAILED;\n                            }\n                          } else {\n                            peg$currPos = s0;\n                            s0 = peg$FAILED;\n                          }\n                        } else {\n                          peg$currPos = s0;\n                          s0 = peg$FAILED;\n                        }\n                        if (s0 === peg$FAILED) {\n                          s0 = peg$currPos;\n                          s1 = peg$parsewhiteUSCFKey();\n                          if (s1 !== peg$FAILED) {\n                            s2 = peg$parsews();\n                            if (s2 !== peg$FAILED) {\n                              s3 = peg$parseintegerString();\n                              if (s3 !== peg$FAILED) {\n                                peg$savedPos = s0;\n                                s1 = peg$c16(s3);\n                                s0 = s1;\n                              } else {\n                                peg$currPos = s0;\n                                s0 = peg$FAILED;\n                              }\n                            } else {\n                              peg$currPos = s0;\n                              s0 = peg$FAILED;\n                            }\n                          } else {\n                            peg$currPos = s0;\n                            s0 = peg$FAILED;\n                          }\n                          if (s0 === peg$FAILED) {\n                            s0 = peg$currPos;\n                            s1 = peg$parseblackUSCFKey();\n                            if (s1 !== peg$FAILED) {\n                              s2 = peg$parsews();\n                              if (s2 !== peg$FAILED) {\n                                s3 = peg$parseintegerString();\n                                if (s3 !== peg$FAILED) {\n                                  peg$savedPos = s0;\n                                  s1 = peg$c17(s3);\n                                  s0 = s1;\n                                } else {\n                                  peg$currPos = s0;\n                                  s0 = peg$FAILED;\n                                }\n                              } else {\n                                peg$currPos = s0;\n                                s0 = peg$FAILED;\n                              }\n                            } else {\n                              peg$currPos = s0;\n                              s0 = peg$FAILED;\n                            }\n                            if (s0 === peg$FAILED) {\n                              s0 = peg$currPos;\n                              s1 = peg$parsewhiteNAKey();\n                              if (s1 !== peg$FAILED) {\n                                s2 = peg$parsews();\n                                if (s2 !== peg$FAILED) {\n                                  s3 = peg$parsestring();\n                                  if (s3 !== peg$FAILED) {\n                                    peg$savedPos = s0;\n                                    s1 = peg$c18(s3);\n                                    s0 = s1;\n                                  } else {\n                                    peg$currPos = s0;\n                                    s0 = peg$FAILED;\n                                  }\n                                } else {\n                                  peg$currPos = s0;\n                                  s0 = peg$FAILED;\n                                }\n                              } else {\n                                peg$currPos = s0;\n                                s0 = peg$FAILED;\n                              }\n                              if (s0 === peg$FAILED) {\n                                s0 = peg$currPos;\n                                s1 = peg$parseblackNAKey();\n                                if (s1 !== peg$FAILED) {\n                                  s2 = peg$parsews();\n                                  if (s2 !== peg$FAILED) {\n                                    s3 = peg$parsestring();\n                                    if (s3 !== peg$FAILED) {\n                                      peg$savedPos = s0;\n                                      s1 = peg$c19(s3);\n                                      s0 = s1;\n                                    } else {\n                                      peg$currPos = s0;\n                                      s0 = peg$FAILED;\n                                    }\n                                  } else {\n                                    peg$currPos = s0;\n                                    s0 = peg$FAILED;\n                                  }\n                                } else {\n                                  peg$currPos = s0;\n                                  s0 = peg$FAILED;\n                                }\n                                if (s0 === peg$FAILED) {\n                                  s0 = peg$currPos;\n                                  s1 = peg$parsewhiteTypeKey();\n                                  if (s1 !== peg$FAILED) {\n                                    s2 = peg$parsews();\n                                    if (s2 !== peg$FAILED) {\n                                      s3 = peg$parsestring();\n                                      if (s3 !== peg$FAILED) {\n                                        peg$savedPos = s0;\n                                        s1 = peg$c20(s3);\n                                        s0 = s1;\n                                      } else {\n                                        peg$currPos = s0;\n                                        s0 = peg$FAILED;\n                                      }\n                                    } else {\n                                      peg$currPos = s0;\n                                      s0 = peg$FAILED;\n                                    }\n                                  } else {\n                                    peg$currPos = s0;\n                                    s0 = peg$FAILED;\n                                  }\n                                  if (s0 === peg$FAILED) {\n                                    s0 = peg$currPos;\n                                    s1 = peg$parseblackTypeKey();\n                                    if (s1 !== peg$FAILED) {\n                                      s2 = peg$parsews();\n                                      if (s2 !== peg$FAILED) {\n                                        s3 = peg$parsestring();\n                                        if (s3 !== peg$FAILED) {\n                                          peg$savedPos = s0;\n                                          s1 = peg$c21(s3);\n                                          s0 = s1;\n                                        } else {\n                                          peg$currPos = s0;\n                                          s0 = peg$FAILED;\n                                        }\n                                      } else {\n                                        peg$currPos = s0;\n                                        s0 = peg$FAILED;\n                                      }\n                                    } else {\n                                      peg$currPos = s0;\n                                      s0 = peg$FAILED;\n                                    }\n                                    if (s0 === peg$FAILED) {\n                                      s0 = peg$currPos;\n                                      s1 = peg$parseeventDateKey();\n                                      if (s1 !== peg$FAILED) {\n                                        s2 = peg$parsews();\n                                        if (s2 !== peg$FAILED) {\n                                          s3 = peg$parsedate();\n                                          if (s3 !== peg$FAILED) {\n                                            peg$savedPos = s0;\n                                            s1 = peg$c22(s3);\n                                            s0 = s1;\n                                          } else {\n                                            peg$currPos = s0;\n                                            s0 = peg$FAILED;\n                                          }\n                                        } else {\n                                          peg$currPos = s0;\n                                          s0 = peg$FAILED;\n                                        }\n                                      } else {\n                                        peg$currPos = s0;\n                                        s0 = peg$FAILED;\n                                      }\n                                      if (s0 === peg$FAILED) {\n                                        s0 = peg$currPos;\n                                        s1 = peg$parseeventSponsorKey();\n                                        if (s1 !== peg$FAILED) {\n                                          s2 = peg$parsews();\n                                          if (s2 !== peg$FAILED) {\n                                            s3 = peg$parsestring();\n                                            if (s3 !== peg$FAILED) {\n                                              peg$savedPos = s0;\n                                              s1 = peg$c23(s3);\n                                              s0 = s1;\n                                            } else {\n                                              peg$currPos = s0;\n                                              s0 = peg$FAILED;\n                                            }\n                                          } else {\n                                            peg$currPos = s0;\n                                            s0 = peg$FAILED;\n                                          }\n                                        } else {\n                                          peg$currPos = s0;\n                                          s0 = peg$FAILED;\n                                        }\n                                        if (s0 === peg$FAILED) {\n                                          s0 = peg$currPos;\n                                          s1 = peg$parsesectionKey();\n                                          if (s1 !== peg$FAILED) {\n                                            s2 = peg$parsews();\n                                            if (s2 !== peg$FAILED) {\n                                              s3 = peg$parsestring();\n                                              if (s3 !== peg$FAILED) {\n                                                peg$savedPos = s0;\n                                                s1 = peg$c24(s3);\n                                                s0 = s1;\n                                              } else {\n                                                peg$currPos = s0;\n                                                s0 = peg$FAILED;\n                                              }\n                                            } else {\n                                              peg$currPos = s0;\n                                              s0 = peg$FAILED;\n                                            }\n                                          } else {\n                                            peg$currPos = s0;\n                                            s0 = peg$FAILED;\n                                          }\n                                          if (s0 === peg$FAILED) {\n                                            s0 = peg$currPos;\n                                            s1 = peg$parsestageKey();\n                                            if (s1 !== peg$FAILED) {\n                                              s2 = peg$parsews();\n                                              if (s2 !== peg$FAILED) {\n                                                s3 = peg$parsestring();\n                                                if (s3 !== peg$FAILED) {\n                                                  peg$savedPos = s0;\n                                                  s1 = peg$c25(s3);\n                                                  s0 = s1;\n                                                } else {\n                                                  peg$currPos = s0;\n                                                  s0 = peg$FAILED;\n                                                }\n                                              } else {\n                                                peg$currPos = s0;\n                                                s0 = peg$FAILED;\n                                              }\n                                            } else {\n                                              peg$currPos = s0;\n                                              s0 = peg$FAILED;\n                                            }\n                                            if (s0 === peg$FAILED) {\n                                              s0 = peg$currPos;\n                                              s1 = peg$parseboardKey();\n                                              if (s1 !== peg$FAILED) {\n                                                s2 = peg$parsews();\n                                                if (s2 !== peg$FAILED) {\n                                                  s3 = peg$parseintegerString();\n                                                  if (s3 !== peg$FAILED) {\n                                                    peg$savedPos = s0;\n                                                    s1 = peg$c26(s3);\n                                                    s0 = s1;\n                                                  } else {\n                                                    peg$currPos = s0;\n                                                    s0 = peg$FAILED;\n                                                  }\n                                                } else {\n                                                  peg$currPos = s0;\n                                                  s0 = peg$FAILED;\n                                                }\n                                              } else {\n                                                peg$currPos = s0;\n                                                s0 = peg$FAILED;\n                                              }\n                                              if (s0 === peg$FAILED) {\n                                                s0 = peg$currPos;\n                                                s1 = peg$parseopeningKey();\n                                                if (s1 !== peg$FAILED) {\n                                                  s2 = peg$parsews();\n                                                  if (s2 !== peg$FAILED) {\n                                                    s3 = peg$parsestring();\n                                                    if (s3 !== peg$FAILED) {\n                                                      peg$savedPos = s0;\n                                                      s1 = peg$c27(s3);\n                                                      s0 = s1;\n                                                    } else {\n                                                      peg$currPos = s0;\n                                                      s0 = peg$FAILED;\n                                                    }\n                                                  } else {\n                                                    peg$currPos = s0;\n                                                    s0 = peg$FAILED;\n                                                  }\n                                                } else {\n                                                  peg$currPos = s0;\n                                                  s0 = peg$FAILED;\n                                                }\n                                                if (s0 === peg$FAILED) {\n                                                  s0 = peg$currPos;\n                                                  s1 = peg$parsevariationKey();\n                                                  if (s1 !== peg$FAILED) {\n                                                    s2 = peg$parsews();\n                                                    if (s2 !== peg$FAILED) {\n                                                      s3 = peg$parsestring();\n                                                      if (s3 !== peg$FAILED) {\n                                                        peg$savedPos = s0;\n                                                        s1 = peg$c28(s3);\n                                                        s0 = s1;\n                                                      } else {\n                                                        peg$currPos = s0;\n                                                        s0 = peg$FAILED;\n                                                      }\n                                                    } else {\n                                                      peg$currPos = s0;\n                                                      s0 = peg$FAILED;\n                                                    }\n                                                  } else {\n                                                    peg$currPos = s0;\n                                                    s0 = peg$FAILED;\n                                                  }\n                                                  if (s0 === peg$FAILED) {\n                                                    s0 = peg$currPos;\n                                                    s1 = peg$parsesubVariationKey();\n                                                    if (s1 !== peg$FAILED) {\n                                                      s2 = peg$parsews();\n                                                      if (s2 !== peg$FAILED) {\n                                                        s3 = peg$parsestring();\n                                                        if (s3 !== peg$FAILED) {\n                                                          peg$savedPos = s0;\n                                                          s1 = peg$c29(s3);\n                                                          s0 = s1;\n                                                        } else {\n                                                          peg$currPos = s0;\n                                                          s0 = peg$FAILED;\n                                                        }\n                                                      } else {\n                                                        peg$currPos = s0;\n                                                        s0 = peg$FAILED;\n                                                      }\n                                                    } else {\n                                                      peg$currPos = s0;\n                                                      s0 = peg$FAILED;\n                                                    }\n                                                    if (s0 === peg$FAILED) {\n                                                      s0 = peg$currPos;\n                                                      s1 = peg$parseecoKey();\n                                                      if (s1 !== peg$FAILED) {\n                                                        s2 = peg$parsews();\n                                                        if (s2 !== peg$FAILED) {\n                                                          s3 = peg$parsestring();\n                                                          if (s3 !== peg$FAILED) {\n                                                            peg$savedPos = s0;\n                                                            s1 = peg$c30(s3);\n                                                            s0 = s1;\n                                                          } else {\n                                                            peg$currPos = s0;\n                                                            s0 = peg$FAILED;\n                                                          }\n                                                        } else {\n                                                          peg$currPos = s0;\n                                                          s0 = peg$FAILED;\n                                                        }\n                                                      } else {\n                                                        peg$currPos = s0;\n                                                        s0 = peg$FAILED;\n                                                      }\n                                                      if (s0 === peg$FAILED) {\n                                                        s0 = peg$currPos;\n                                                        s1 = peg$parsenicKey();\n                                                        if (s1 !== peg$FAILED) {\n                                                          s2 = peg$parsews();\n                                                          if (s2 !== peg$FAILED) {\n                                                            s3 = peg$parsestring();\n                                                            if (s3 !== peg$FAILED) {\n                                                              peg$savedPos = s0;\n                                                              s1 = peg$c31(s3);\n                                                              s0 = s1;\n                                                            } else {\n                                                              peg$currPos = s0;\n                                                              s0 = peg$FAILED;\n                                                            }\n                                                          } else {\n                                                            peg$currPos = s0;\n                                                            s0 = peg$FAILED;\n                                                          }\n                                                        } else {\n                                                          peg$currPos = s0;\n                                                          s0 = peg$FAILED;\n                                                        }\n                                                        if (s0 === peg$FAILED) {\n                                                          s0 = peg$currPos;\n                                                          s1 = peg$parsetimeKey();\n                                                          if (s1 !== peg$FAILED) {\n                                                            s2 = peg$parsews();\n                                                            if (s2 !== peg$FAILED) {\n                                                              s3 = peg$parsestring();\n                                                              if (s3 !== peg$FAILED) {\n                                                                peg$savedPos = s0;\n                                                                s1 = peg$c32(s3);\n                                                                s0 = s1;\n                                                              } else {\n                                                                peg$currPos = s0;\n                                                                s0 = peg$FAILED;\n                                                              }\n                                                            } else {\n                                                              peg$currPos = s0;\n                                                              s0 = peg$FAILED;\n                                                            }\n                                                          } else {\n                                                            peg$currPos = s0;\n                                                            s0 = peg$FAILED;\n                                                          }\n                                                          if (s0 === peg$FAILED) {\n                                                            s0 = peg$currPos;\n                                                            s1 = peg$parseutcTimeKey();\n                                                            if (s1 !== peg$FAILED) {\n                                                              s2 = peg$parsews();\n                                                              if (s2 !== peg$FAILED) {\n                                                                s3 = peg$parsestring();\n                                                                if (s3 !== peg$FAILED) {\n                                                                  peg$savedPos = s0;\n                                                                  s1 = peg$c33(s3);\n                                                                  s0 = s1;\n                                                                } else {\n                                                                  peg$currPos = s0;\n                                                                  s0 = peg$FAILED;\n                                                                }\n                                                              } else {\n                                                                peg$currPos = s0;\n                                                                s0 = peg$FAILED;\n                                                              }\n                                                            } else {\n                                                              peg$currPos = s0;\n                                                              s0 = peg$FAILED;\n                                                            }\n                                                            if (s0 === peg$FAILED) {\n                                                              s0 = peg$currPos;\n                                                              s1 = peg$parseutcDateKey();\n                                                              if (s1 !== peg$FAILED) {\n                                                                s2 = peg$parsews();\n                                                                if (s2 !== peg$FAILED) {\n                                                                  s3 = peg$parsestring();\n                                                                  if (s3 !== peg$FAILED) {\n                                                                    peg$savedPos = s0;\n                                                                    s1 = peg$c34(s3);\n                                                                    s0 = s1;\n                                                                  } else {\n                                                                    peg$currPos = s0;\n                                                                    s0 = peg$FAILED;\n                                                                  }\n                                                                } else {\n                                                                  peg$currPos = s0;\n                                                                  s0 = peg$FAILED;\n                                                                }\n                                                              } else {\n                                                                peg$currPos = s0;\n                                                                s0 = peg$FAILED;\n                                                              }\n                                                              if (s0 === peg$FAILED) {\n                                                                s0 = peg$currPos;\n                                                                s1 = peg$parsetimeControlKey();\n                                                                if (s1 !== peg$FAILED) {\n                                                                  s2 = peg$parsews();\n                                                                  if (s2 !== peg$FAILED) {\n                                                                    s3 = peg$parsestring();\n                                                                    if (s3 !== peg$FAILED) {\n                                                                      peg$savedPos = s0;\n                                                                      s1 = peg$c35(s3);\n                                                                      s0 = s1;\n                                                                    } else {\n                                                                      peg$currPos = s0;\n                                                                      s0 = peg$FAILED;\n                                                                    }\n                                                                  } else {\n                                                                    peg$currPos = s0;\n                                                                    s0 = peg$FAILED;\n                                                                  }\n                                                                } else {\n                                                                  peg$currPos = s0;\n                                                                  s0 = peg$FAILED;\n                                                                }\n                                                                if (s0 === peg$FAILED) {\n                                                                  s0 = peg$currPos;\n                                                                  s1 = peg$parsesetUpKey();\n                                                                  if (s1 !== peg$FAILED) {\n                                                                    s2 = peg$parsews();\n                                                                    if (s2 !== peg$FAILED) {\n                                                                      s3 = peg$parsestring();\n                                                                      if (s3 !== peg$FAILED) {\n                                                                        peg$savedPos = s0;\n                                                                        s1 = peg$c36(s3);\n                                                                        s0 = s1;\n                                                                      } else {\n                                                                        peg$currPos = s0;\n                                                                        s0 = peg$FAILED;\n                                                                      }\n                                                                    } else {\n                                                                      peg$currPos = s0;\n                                                                      s0 = peg$FAILED;\n                                                                    }\n                                                                  } else {\n                                                                    peg$currPos = s0;\n                                                                    s0 = peg$FAILED;\n                                                                  }\n                                                                  if (s0 === peg$FAILED) {\n                                                                    s0 = peg$currPos;\n                                                                    s1 = peg$parsefenKey();\n                                                                    if (s1 !== peg$FAILED) {\n                                                                      s2 = peg$parsews();\n                                                                      if (s2 !== peg$FAILED) {\n                                                                        s3 = peg$parsestring();\n                                                                        if (s3 !== peg$FAILED) {\n                                                                          peg$savedPos = s0;\n                                                                          s1 = peg$c37(s3);\n                                                                          s0 = s1;\n                                                                        } else {\n                                                                          peg$currPos = s0;\n                                                                          s0 = peg$FAILED;\n                                                                        }\n                                                                      } else {\n                                                                        peg$currPos = s0;\n                                                                        s0 = peg$FAILED;\n                                                                      }\n                                                                    } else {\n                                                                      peg$currPos = s0;\n                                                                      s0 = peg$FAILED;\n                                                                    }\n                                                                    if (s0 === peg$FAILED) {\n                                                                      s0 = peg$currPos;\n                                                                      s1 = peg$parseterminationKey();\n                                                                      if (s1 !== peg$FAILED) {\n                                                                        s2 = peg$parsews();\n                                                                        if (s2 !== peg$FAILED) {\n                                                                          s3 = peg$parsestring();\n                                                                          if (s3 !== peg$FAILED) {\n                                                                            peg$savedPos = s0;\n                                                                            s1 = peg$c38(s3);\n                                                                            s0 = s1;\n                                                                          } else {\n                                                                            peg$currPos = s0;\n                                                                            s0 = peg$FAILED;\n                                                                          }\n                                                                        } else {\n                                                                          peg$currPos = s0;\n                                                                          s0 = peg$FAILED;\n                                                                        }\n                                                                      } else {\n                                                                        peg$currPos = s0;\n                                                                        s0 = peg$FAILED;\n                                                                      }\n                                                                      if (s0 === peg$FAILED) {\n                                                                        s0 = peg$currPos;\n                                                                        s1 = peg$parseanotatorKey();\n                                                                        if (s1 !== peg$FAILED) {\n                                                                          s2 = peg$parsews();\n                                                                          if (s2 !== peg$FAILED) {\n                                                                            s3 = peg$parsestring();\n                                                                            if (s3 !== peg$FAILED) {\n                                                                              peg$savedPos = s0;\n                                                                              s1 = peg$c39(s3);\n                                                                              s0 = s1;\n                                                                            } else {\n                                                                              peg$currPos = s0;\n                                                                              s0 = peg$FAILED;\n                                                                            }\n                                                                          } else {\n                                                                            peg$currPos = s0;\n                                                                            s0 = peg$FAILED;\n                                                                          }\n                                                                        } else {\n                                                                          peg$currPos = s0;\n                                                                          s0 = peg$FAILED;\n                                                                        }\n                                                                        if (s0 === peg$FAILED) {\n                                                                          s0 = peg$currPos;\n                                                                          s1 = peg$parsemodeKey();\n                                                                          if (s1 !== peg$FAILED) {\n                                                                            s2 = peg$parsews();\n                                                                            if (s2 !== peg$FAILED) {\n                                                                              s3 = peg$parsestring();\n                                                                              if (s3 !== peg$FAILED) {\n                                                                                peg$savedPos = s0;\n                                                                                s1 = peg$c40(s3);\n                                                                                s0 = s1;\n                                                                              } else {\n                                                                                peg$currPos = s0;\n                                                                                s0 = peg$FAILED;\n                                                                              }\n                                                                            } else {\n                                                                              peg$currPos = s0;\n                                                                              s0 = peg$FAILED;\n                                                                            }\n                                                                          } else {\n                                                                            peg$currPos = s0;\n                                                                            s0 = peg$FAILED;\n                                                                          }\n                                                                          if (s0 === peg$FAILED) {\n                                                                            s0 = peg$currPos;\n                                                                            s1 = peg$parseplyCountKey();\n                                                                            if (s1 !== peg$FAILED) {\n                                                                              s2 = peg$parsews();\n                                                                              if (s2 !== peg$FAILED) {\n                                                                                s3 = peg$parseintegerString();\n                                                                                if (s3 !== peg$FAILED) {\n                                                                                  peg$savedPos = s0;\n                                                                                  s1 = peg$c41(s3);\n                                                                                  s0 = s1;\n                                                                                } else {\n                                                                                  peg$currPos = s0;\n                                                                                  s0 = peg$FAILED;\n                                                                                }\n                                                                              } else {\n                                                                                peg$currPos = s0;\n                                                                                s0 = peg$FAILED;\n                                                                              }\n                                                                            } else {\n                                                                              peg$currPos = s0;\n                                                                              s0 = peg$FAILED;\n                                                                            }\n                                                                          }\n                                                                        }\n                                                                      }\n                                                                    }\n                                                                  }\n                                                                }\n                                                              }\n                                                            }\n                                                          }\n                                                        }\n                                                      }\n                                                    }\n                                                  }\n                                                }\n                                              }\n                                            }\n                                          }\n                                        }\n                                      }\n                                    }\n                                  }\n                                }\n                              }\n                            }\n                          }\n                        }\n                      }\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n\n    return s0;\n  }\n\n  function peg$parseeventKey() {\n    var s0;\n\n    if (input.substr(peg$currPos, 5) === peg$c42) {\n      s0 = peg$c42;\n      peg$currPos += 5;\n    } else {\n      s0 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c43); }\n    }\n\n    return s0;\n  }\n\n  function peg$parsesiteKey() {\n    var s0;\n\n    if (input.substr(peg$currPos, 4) === peg$c44) {\n      s0 = peg$c44;\n      peg$currPos += 4;\n    } else {\n      s0 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c45); }\n    }\n\n    return s0;\n  }\n\n  function peg$parsedateKey() {\n    var s0;\n\n    if (input.substr(peg$currPos, 4) === peg$c46) {\n      s0 = peg$c46;\n      peg$currPos += 4;\n    } else {\n      s0 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c47); }\n    }\n\n    return s0;\n  }\n\n  function peg$parseroundKey() {\n    var s0;\n\n    if (input.substr(peg$currPos, 5) === peg$c48) {\n      s0 = peg$c48;\n      peg$currPos += 5;\n    } else {\n      s0 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c49); }\n    }\n\n    return s0;\n  }\n\n  function peg$parsewhiteKey() {\n    var s0;\n\n    if (input.substr(peg$currPos, 5) === peg$c50) {\n      s0 = peg$c50;\n      peg$currPos += 5;\n    } else {\n      s0 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c51); }\n    }\n\n    return s0;\n  }\n\n  function peg$parseblackKey() {\n    var s0;\n\n    if (input.substr(peg$currPos, 5) === peg$c52) {\n      s0 = peg$c52;\n      peg$currPos += 5;\n    } else {\n      s0 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c53); }\n    }\n\n    return s0;\n  }\n\n  function peg$parseresultKey() {\n    var s0;\n\n    if (input.substr(peg$currPos, 6) === peg$c54) {\n      s0 = peg$c54;\n      peg$currPos += 6;\n    } else {\n      s0 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c55); }\n    }\n\n    return s0;\n  }\n\n  function peg$parsewhiteTitleKey() {\n    var s0;\n\n    if (input.substr(peg$currPos, 10) === peg$c56) {\n      s0 = peg$c56;\n      peg$currPos += 10;\n    } else {\n      s0 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c57); }\n    }\n\n    return s0;\n  }\n\n  function peg$parseblackTitleKey() {\n    var s0;\n\n    if (input.substr(peg$currPos, 10) === peg$c58) {\n      s0 = peg$c58;\n      peg$currPos += 10;\n    } else {\n      s0 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c59); }\n    }\n\n    return s0;\n  }\n\n  function peg$parsewhiteEloKey() {\n    var s0;\n\n    if (input.substr(peg$currPos, 8) === peg$c60) {\n      s0 = peg$c60;\n      peg$currPos += 8;\n    } else {\n      s0 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c61); }\n    }\n\n    return s0;\n  }\n\n  function peg$parseblackEloKey() {\n    var s0;\n\n    if (input.substr(peg$currPos, 8) === peg$c62) {\n      s0 = peg$c62;\n      peg$currPos += 8;\n    } else {\n      s0 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c63); }\n    }\n\n    return s0;\n  }\n\n  function peg$parsewhiteUSCFKey() {\n    var s0;\n\n    if (input.substr(peg$currPos, 9) === peg$c64) {\n      s0 = peg$c64;\n      peg$currPos += 9;\n    } else {\n      s0 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c65); }\n    }\n\n    return s0;\n  }\n\n  function peg$parseblackUSCFKey() {\n    var s0;\n\n    if (input.substr(peg$currPos, 9) === peg$c66) {\n      s0 = peg$c66;\n      peg$currPos += 9;\n    } else {\n      s0 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c67); }\n    }\n\n    return s0;\n  }\n\n  function peg$parsewhiteNAKey() {\n    var s0;\n\n    if (input.substr(peg$currPos, 7) === peg$c68) {\n      s0 = peg$c68;\n      peg$currPos += 7;\n    } else {\n      s0 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c69); }\n    }\n\n    return s0;\n  }\n\n  function peg$parseblackNAKey() {\n    var s0;\n\n    if (input.substr(peg$currPos, 7) === peg$c70) {\n      s0 = peg$c70;\n      peg$currPos += 7;\n    } else {\n      s0 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c71); }\n    }\n\n    return s0;\n  }\n\n  function peg$parsewhiteTypeKey() {\n    var s0;\n\n    if (input.substr(peg$currPos, 9) === peg$c72) {\n      s0 = peg$c72;\n      peg$currPos += 9;\n    } else {\n      s0 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c73); }\n    }\n\n    return s0;\n  }\n\n  function peg$parseblackTypeKey() {\n    var s0;\n\n    if (input.substr(peg$currPos, 9) === peg$c74) {\n      s0 = peg$c74;\n      peg$currPos += 9;\n    } else {\n      s0 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c75); }\n    }\n\n    return s0;\n  }\n\n  function peg$parseeventDateKey() {\n    var s0;\n\n    if (input.substr(peg$currPos, 9) === peg$c76) {\n      s0 = peg$c76;\n      peg$currPos += 9;\n    } else {\n      s0 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c77); }\n    }\n\n    return s0;\n  }\n\n  function peg$parseeventSponsorKey() {\n    var s0;\n\n    if (input.substr(peg$currPos, 12) === peg$c78) {\n      s0 = peg$c78;\n      peg$currPos += 12;\n    } else {\n      s0 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c79); }\n    }\n\n    return s0;\n  }\n\n  function peg$parsesectionKey() {\n    var s0;\n\n    if (input.substr(peg$currPos, 7) === peg$c80) {\n      s0 = peg$c80;\n      peg$currPos += 7;\n    } else {\n      s0 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c81); }\n    }\n\n    return s0;\n  }\n\n  function peg$parsestageKey() {\n    var s0;\n\n    if (input.substr(peg$currPos, 5) === peg$c82) {\n      s0 = peg$c82;\n      peg$currPos += 5;\n    } else {\n      s0 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c83); }\n    }\n\n    return s0;\n  }\n\n  function peg$parseboardKey() {\n    var s0;\n\n    if (input.substr(peg$currPos, 5) === peg$c84) {\n      s0 = peg$c84;\n      peg$currPos += 5;\n    } else {\n      s0 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c85); }\n    }\n\n    return s0;\n  }\n\n  function peg$parseopeningKey() {\n    var s0;\n\n    if (input.substr(peg$currPos, 7) === peg$c86) {\n      s0 = peg$c86;\n      peg$currPos += 7;\n    } else {\n      s0 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c87); }\n    }\n\n    return s0;\n  }\n\n  function peg$parsevariationKey() {\n    var s0;\n\n    if (input.substr(peg$currPos, 9) === peg$c88) {\n      s0 = peg$c88;\n      peg$currPos += 9;\n    } else {\n      s0 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c89); }\n    }\n\n    return s0;\n  }\n\n  function peg$parsesubVariationKey() {\n    var s0;\n\n    if (input.substr(peg$currPos, 12) === peg$c90) {\n      s0 = peg$c90;\n      peg$currPos += 12;\n    } else {\n      s0 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c91); }\n    }\n\n    return s0;\n  }\n\n  function peg$parseecoKey() {\n    var s0;\n\n    if (input.substr(peg$currPos, 3) === peg$c92) {\n      s0 = peg$c92;\n      peg$currPos += 3;\n    } else {\n      s0 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c93); }\n    }\n\n    return s0;\n  }\n\n  function peg$parsenicKey() {\n    var s0;\n\n    if (input.substr(peg$currPos, 3) === peg$c94) {\n      s0 = peg$c94;\n      peg$currPos += 3;\n    } else {\n      s0 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c95); }\n    }\n\n    return s0;\n  }\n\n  function peg$parsetimeKey() {\n    var s0;\n\n    if (input.substr(peg$currPos, 4) === peg$c96) {\n      s0 = peg$c96;\n      peg$currPos += 4;\n    } else {\n      s0 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c97); }\n    }\n\n    return s0;\n  }\n\n  function peg$parseutcTimeKey() {\n    var s0;\n\n    if (input.substr(peg$currPos, 7) === peg$c98) {\n      s0 = peg$c98;\n      peg$currPos += 7;\n    } else {\n      s0 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c99); }\n    }\n\n    return s0;\n  }\n\n  function peg$parseutcDateKey() {\n    var s0;\n\n    if (input.substr(peg$currPos, 7) === peg$c100) {\n      s0 = peg$c100;\n      peg$currPos += 7;\n    } else {\n      s0 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c101); }\n    }\n\n    return s0;\n  }\n\n  function peg$parsetimeControlKey() {\n    var s0;\n\n    if (input.substr(peg$currPos, 11) === peg$c102) {\n      s0 = peg$c102;\n      peg$currPos += 11;\n    } else {\n      s0 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c103); }\n    }\n\n    return s0;\n  }\n\n  function peg$parsesetUpKey() {\n    var s0;\n\n    if (input.substr(peg$currPos, 5) === peg$c104) {\n      s0 = peg$c104;\n      peg$currPos += 5;\n    } else {\n      s0 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c105); }\n    }\n\n    return s0;\n  }\n\n  function peg$parsefenKey() {\n    var s0;\n\n    if (input.substr(peg$currPos, 3) === peg$c106) {\n      s0 = peg$c106;\n      peg$currPos += 3;\n    } else {\n      s0 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c107); }\n    }\n\n    return s0;\n  }\n\n  function peg$parseterminationKey() {\n    var s0;\n\n    if (input.substr(peg$currPos, 11) === peg$c108) {\n      s0 = peg$c108;\n      peg$currPos += 11;\n    } else {\n      s0 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c109); }\n    }\n\n    return s0;\n  }\n\n  function peg$parseanotatorKey() {\n    var s0;\n\n    if (input.substr(peg$currPos, 9) === peg$c110) {\n      s0 = peg$c110;\n      peg$currPos += 9;\n    } else {\n      s0 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c111); }\n    }\n\n    return s0;\n  }\n\n  function peg$parsemodeKey() {\n    var s0;\n\n    if (input.substr(peg$currPos, 4) === peg$c112) {\n      s0 = peg$c112;\n      peg$currPos += 4;\n    } else {\n      s0 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c113); }\n    }\n\n    return s0;\n  }\n\n  function peg$parseplyCountKey() {\n    var s0;\n\n    if (input.substr(peg$currPos, 8) === peg$c114) {\n      s0 = peg$c114;\n      peg$currPos += 8;\n    } else {\n      s0 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c115); }\n    }\n\n    return s0;\n  }\n\n  function peg$parsews() {\n    var s0, s1;\n\n    peg$silentFails++;\n    s0 = [];\n    if (peg$c117.test(input.charAt(peg$currPos))) {\n      s1 = input.charAt(peg$currPos);\n      peg$currPos++;\n    } else {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c118); }\n    }\n    while (s1 !== peg$FAILED) {\n      s0.push(s1);\n      if (peg$c117.test(input.charAt(peg$currPos))) {\n        s1 = input.charAt(peg$currPos);\n        peg$currPos++;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c118); }\n      }\n    }\n    peg$silentFails--;\n    if (s0 === peg$FAILED) {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c116); }\n    }\n\n    return s0;\n  }\n\n  function peg$parsestring() {\n    var s0, s1, s2, s3;\n\n    peg$silentFails++;\n    s0 = peg$currPos;\n    s1 = peg$parsequotation_mark();\n    if (s1 !== peg$FAILED) {\n      s2 = [];\n      s3 = peg$parsechar();\n      while (s3 !== peg$FAILED) {\n        s2.push(s3);\n        s3 = peg$parsechar();\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parsequotation_mark();\n        if (s3 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s1 = peg$c120(s2);\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n    peg$silentFails--;\n    if (s0 === peg$FAILED) {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c119); }\n    }\n\n    return s0;\n  }\n\n  function peg$parsequotation_mark() {\n    var s0;\n\n    if (input.charCodeAt(peg$currPos) === 34) {\n      s0 = peg$c121;\n      peg$currPos++;\n    } else {\n      s0 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c122); }\n    }\n\n    return s0;\n  }\n\n  function peg$parsechar() {\n    var s0;\n\n    if (peg$c123.test(input.charAt(peg$currPos))) {\n      s0 = input.charAt(peg$currPos);\n      peg$currPos++;\n    } else {\n      s0 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c124); }\n    }\n\n    return s0;\n  }\n\n  function peg$parsedate() {\n    var s0, s1, s2, s3, s4, s5, s6, s7, s8;\n\n    s0 = peg$currPos;\n    s1 = peg$parsequotation_mark();\n    if (s1 !== peg$FAILED) {\n      s2 = peg$currPos;\n      if (peg$c125.test(input.charAt(peg$currPos))) {\n        s3 = input.charAt(peg$currPos);\n        peg$currPos++;\n      } else {\n        s3 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c126); }\n      }\n      if (s3 !== peg$FAILED) {\n        if (peg$c125.test(input.charAt(peg$currPos))) {\n          s4 = input.charAt(peg$currPos);\n          peg$currPos++;\n        } else {\n          s4 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c126); }\n        }\n        if (s4 !== peg$FAILED) {\n          if (peg$c125.test(input.charAt(peg$currPos))) {\n            s5 = input.charAt(peg$currPos);\n            peg$currPos++;\n          } else {\n            s5 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c126); }\n          }\n          if (s5 !== peg$FAILED) {\n            if (peg$c125.test(input.charAt(peg$currPos))) {\n              s6 = input.charAt(peg$currPos);\n              peg$currPos++;\n            } else {\n              s6 = peg$FAILED;\n              if (peg$silentFails === 0) { peg$fail(peg$c126); }\n            }\n            if (s6 !== peg$FAILED) {\n              s3 = [s3, s4, s5, s6];\n              s2 = s3;\n            } else {\n              peg$currPos = s2;\n              s2 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s2;\n            s2 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s2;\n          s2 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s2;\n        s2 = peg$FAILED;\n      }\n      if (s2 !== peg$FAILED) {\n        if (input.charCodeAt(peg$currPos) === 46) {\n          s3 = peg$c127;\n          peg$currPos++;\n        } else {\n          s3 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c128); }\n        }\n        if (s3 !== peg$FAILED) {\n          s4 = peg$currPos;\n          if (peg$c125.test(input.charAt(peg$currPos))) {\n            s5 = input.charAt(peg$currPos);\n            peg$currPos++;\n          } else {\n            s5 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c126); }\n          }\n          if (s5 !== peg$FAILED) {\n            if (peg$c125.test(input.charAt(peg$currPos))) {\n              s6 = input.charAt(peg$currPos);\n              peg$currPos++;\n            } else {\n              s6 = peg$FAILED;\n              if (peg$silentFails === 0) { peg$fail(peg$c126); }\n            }\n            if (s6 !== peg$FAILED) {\n              s5 = [s5, s6];\n              s4 = s5;\n            } else {\n              peg$currPos = s4;\n              s4 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s4;\n            s4 = peg$FAILED;\n          }\n          if (s4 !== peg$FAILED) {\n            if (input.charCodeAt(peg$currPos) === 46) {\n              s5 = peg$c127;\n              peg$currPos++;\n            } else {\n              s5 = peg$FAILED;\n              if (peg$silentFails === 0) { peg$fail(peg$c128); }\n            }\n            if (s5 !== peg$FAILED) {\n              s6 = peg$currPos;\n              if (peg$c125.test(input.charAt(peg$currPos))) {\n                s7 = input.charAt(peg$currPos);\n                peg$currPos++;\n              } else {\n                s7 = peg$FAILED;\n                if (peg$silentFails === 0) { peg$fail(peg$c126); }\n              }\n              if (s7 !== peg$FAILED) {\n                if (peg$c125.test(input.charAt(peg$currPos))) {\n                  s8 = input.charAt(peg$currPos);\n                  peg$currPos++;\n                } else {\n                  s8 = peg$FAILED;\n                  if (peg$silentFails === 0) { peg$fail(peg$c126); }\n                }\n                if (s8 !== peg$FAILED) {\n                  s7 = [s7, s8];\n                  s6 = s7;\n                } else {\n                  peg$currPos = s6;\n                  s6 = peg$FAILED;\n                }\n              } else {\n                peg$currPos = s6;\n                s6 = peg$FAILED;\n              }\n              if (s6 !== peg$FAILED) {\n                s7 = peg$parsequotation_mark();\n                if (s7 !== peg$FAILED) {\n                  peg$savedPos = s0;\n                  s1 = peg$c129(s2, s4, s6);\n                  s0 = s1;\n                } else {\n                  peg$currPos = s0;\n                  s0 = peg$FAILED;\n                }\n              } else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parseresult() {\n    var s0, s1, s2, s3;\n\n    s0 = peg$currPos;\n    s1 = peg$parsequotation_mark();\n    if (s1 !== peg$FAILED) {\n      s2 = peg$parseinner_result();\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parsequotation_mark();\n        if (s3 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s1 = peg$c130(s2);\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parseinner_result() {\n    var s0, s1;\n\n    s0 = peg$currPos;\n    if (input.substr(peg$currPos, 3) === peg$c131) {\n      s1 = peg$c131;\n      peg$currPos += 3;\n    } else {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c132); }\n    }\n    if (s1 !== peg$FAILED) {\n      peg$savedPos = s0;\n      s1 = peg$c133(s1);\n    }\n    s0 = s1;\n    if (s0 === peg$FAILED) {\n      s0 = peg$currPos;\n      if (input.substr(peg$currPos, 3) === peg$c134) {\n        s1 = peg$c134;\n        peg$currPos += 3;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c135); }\n      }\n      if (s1 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s1 = peg$c130(s1);\n      }\n      s0 = s1;\n      if (s0 === peg$FAILED) {\n        s0 = peg$currPos;\n        if (input.substr(peg$currPos, 3) === peg$c136) {\n          s1 = peg$c136;\n          peg$currPos += 3;\n        } else {\n          s1 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c137); }\n        }\n        if (s1 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s1 = peg$c130(s1);\n        }\n        s0 = s1;\n        if (s0 === peg$FAILED) {\n          s0 = peg$currPos;\n          if (input.substr(peg$currPos, 3) === peg$c138) {\n            s1 = peg$c138;\n            peg$currPos += 3;\n          } else {\n            s1 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c139); }\n          }\n          if (s1 !== peg$FAILED) {\n            peg$savedPos = s0;\n            s1 = peg$c130(s1);\n          }\n          s0 = s1;\n          if (s0 === peg$FAILED) {\n            s0 = peg$currPos;\n            if (input.substr(peg$currPos, 7) === peg$c140) {\n              s1 = peg$c140;\n              peg$currPos += 7;\n            } else {\n              s1 = peg$FAILED;\n              if (peg$silentFails === 0) { peg$fail(peg$c141); }\n            }\n            if (s1 !== peg$FAILED) {\n              peg$savedPos = s0;\n              s1 = peg$c130(s1);\n            }\n            s0 = s1;\n            if (s0 === peg$FAILED) {\n              s0 = peg$currPos;\n              if (input.charCodeAt(peg$currPos) === 42) {\n                s1 = peg$c142;\n                peg$currPos++;\n              } else {\n                s1 = peg$FAILED;\n                if (peg$silentFails === 0) { peg$fail(peg$c143); }\n              }\n              if (s1 !== peg$FAILED) {\n                peg$savedPos = s0;\n                s1 = peg$c130(s1);\n              }\n              s0 = s1;\n            }\n          }\n        }\n      }\n    }\n\n    return s0;\n  }\n\n  function peg$parseintegerOrDash() {\n    var s0, s1, s2, s3;\n\n    s0 = peg$parseintegerString();\n    if (s0 === peg$FAILED) {\n      s0 = peg$currPos;\n      s1 = peg$parsequotation_mark();\n      if (s1 !== peg$FAILED) {\n        if (input.charCodeAt(peg$currPos) === 45) {\n          s2 = peg$c144;\n          peg$currPos++;\n        } else {\n          s2 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c145); }\n        }\n        if (s2 !== peg$FAILED) {\n          s3 = peg$parsequotation_mark();\n          if (s3 !== peg$FAILED) {\n            s1 = [s1, s2, s3];\n            s0 = s1;\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    }\n\n    return s0;\n  }\n\n  function peg$parseintegerString() {\n    var s0, s1, s2, s3;\n\n    s0 = peg$currPos;\n    s1 = peg$parsequotation_mark();\n    if (s1 !== peg$FAILED) {\n      s2 = [];\n      if (peg$c125.test(input.charAt(peg$currPos))) {\n        s3 = input.charAt(peg$currPos);\n        peg$currPos++;\n      } else {\n        s3 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c126); }\n      }\n      if (s3 !== peg$FAILED) {\n        while (s3 !== peg$FAILED) {\n          s2.push(s3);\n          if (peg$c125.test(input.charAt(peg$currPos))) {\n            s3 = input.charAt(peg$currPos);\n            peg$currPos++;\n          } else {\n            s3 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c126); }\n          }\n        }\n      } else {\n        s2 = peg$FAILED;\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parsequotation_mark();\n        if (s3 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s1 = peg$c146(s2);\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parsepgn() {\n    var s0, s1, s2;\n\n    s0 = peg$currPos;\n    s1 = peg$parsepgnStartWhite();\n    if (s1 !== peg$FAILED) {\n      s2 = peg$parsepgnBlack();\n      if (s2 === peg$FAILED) {\n        s2 = null;\n      }\n      if (s2 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s1 = peg$c147(s1, s2);\n        s0 = s1;\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n    if (s0 === peg$FAILED) {\n      s0 = peg$currPos;\n      s1 = peg$parsepgnStartBlack();\n      if (s1 !== peg$FAILED) {\n        s2 = peg$parsepgnWhite();\n        if (s2 === peg$FAILED) {\n          s2 = null;\n        }\n        if (s2 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s1 = peg$c148(s1, s2);\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n      if (s0 === peg$FAILED) {\n        s0 = peg$currPos;\n        s1 = peg$parsewhiteSpace();\n        if (s1 === peg$FAILED) {\n          s1 = null;\n        }\n        if (s1 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s1 = peg$c149();\n        }\n        s0 = s1;\n      }\n    }\n\n    return s0;\n  }\n\n  function peg$parsepgnStartWhite() {\n    var s0, s1;\n\n    s0 = peg$currPos;\n    s1 = peg$parsepgnWhite();\n    if (s1 !== peg$FAILED) {\n      peg$savedPos = s0;\n      s1 = peg$c150(s1);\n    }\n    s0 = s1;\n\n    return s0;\n  }\n\n  function peg$parsepgnStartBlack() {\n    var s0, s1;\n\n    s0 = peg$currPos;\n    s1 = peg$parsepgnBlack();\n    if (s1 !== peg$FAILED) {\n      peg$savedPos = s0;\n      s1 = peg$c151(s1);\n    }\n    s0 = s1;\n\n    return s0;\n  }\n\n  function peg$parsepgnWhite() {\n    var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9, s10, s11, s12, s13, s14, s15, s16, s17;\n\n    s0 = peg$currPos;\n    s1 = peg$parsewhiteSpace();\n    if (s1 === peg$FAILED) {\n      s1 = null;\n    }\n    if (s1 !== peg$FAILED) {\n      s2 = peg$parsecomments();\n      if (s2 === peg$FAILED) {\n        s2 = null;\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parsewhiteSpace();\n        if (s3 === peg$FAILED) {\n          s3 = null;\n        }\n        if (s3 !== peg$FAILED) {\n          s4 = peg$parsemoveNumber();\n          if (s4 === peg$FAILED) {\n            s4 = null;\n          }\n          if (s4 !== peg$FAILED) {\n            s5 = peg$parsewhiteSpace();\n            if (s5 === peg$FAILED) {\n              s5 = null;\n            }\n            if (s5 !== peg$FAILED) {\n              s6 = peg$parsecomments();\n              if (s6 === peg$FAILED) {\n                s6 = null;\n              }\n              if (s6 !== peg$FAILED) {\n                s7 = peg$parsewhiteSpace();\n                if (s7 === peg$FAILED) {\n                  s7 = null;\n                }\n                if (s7 !== peg$FAILED) {\n                  s8 = peg$parsehalfMove();\n                  if (s8 !== peg$FAILED) {\n                    s9 = peg$parsewhiteSpace();\n                    if (s9 === peg$FAILED) {\n                      s9 = null;\n                    }\n                    if (s9 !== peg$FAILED) {\n                      s10 = peg$parsenags();\n                      if (s10 === peg$FAILED) {\n                        s10 = null;\n                      }\n                      if (s10 !== peg$FAILED) {\n                        s11 = peg$parsewhiteSpace();\n                        if (s11 === peg$FAILED) {\n                          s11 = null;\n                        }\n                        if (s11 !== peg$FAILED) {\n                          s12 = peg$parsecomments();\n                          if (s12 === peg$FAILED) {\n                            s12 = null;\n                          }\n                          if (s12 !== peg$FAILED) {\n                            s13 = peg$parsewhiteSpace();\n                            if (s13 === peg$FAILED) {\n                              s13 = null;\n                            }\n                            if (s13 !== peg$FAILED) {\n                              s14 = peg$parsecommentDiag();\n                              if (s14 === peg$FAILED) {\n                                s14 = null;\n                              }\n                              if (s14 !== peg$FAILED) {\n                                s15 = peg$parsewhiteSpace();\n                                if (s15 === peg$FAILED) {\n                                  s15 = null;\n                                }\n                                if (s15 !== peg$FAILED) {\n                                  s16 = peg$parsevariationWhite();\n                                  if (s16 === peg$FAILED) {\n                                    s16 = null;\n                                  }\n                                  if (s16 !== peg$FAILED) {\n                                    s17 = peg$parsepgnBlack();\n                                    if (s17 === peg$FAILED) {\n                                      s17 = null;\n                                    }\n                                    if (s17 !== peg$FAILED) {\n                                      peg$savedPos = s0;\n                                      s1 = peg$c152(s2, s4, s6, s8, s10, s12, s14, s16, s17);\n                                      s0 = s1;\n                                    } else {\n                                      peg$currPos = s0;\n                                      s0 = peg$FAILED;\n                                    }\n                                  } else {\n                                    peg$currPos = s0;\n                                    s0 = peg$FAILED;\n                                  }\n                                } else {\n                                  peg$currPos = s0;\n                                  s0 = peg$FAILED;\n                                }\n                              } else {\n                                peg$currPos = s0;\n                                s0 = peg$FAILED;\n                              }\n                            } else {\n                              peg$currPos = s0;\n                              s0 = peg$FAILED;\n                            }\n                          } else {\n                            peg$currPos = s0;\n                            s0 = peg$FAILED;\n                          }\n                        } else {\n                          peg$currPos = s0;\n                          s0 = peg$FAILED;\n                        }\n                      } else {\n                        peg$currPos = s0;\n                        s0 = peg$FAILED;\n                      }\n                    } else {\n                      peg$currPos = s0;\n                      s0 = peg$FAILED;\n                    }\n                  } else {\n                    peg$currPos = s0;\n                    s0 = peg$FAILED;\n                  }\n                } else {\n                  peg$currPos = s0;\n                  s0 = peg$FAILED;\n                }\n              } else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n    if (s0 === peg$FAILED) {\n      s0 = peg$parseendGame();\n    }\n\n    return s0;\n  }\n\n  function peg$parsepgnBlack() {\n    var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9, s10, s11, s12, s13, s14, s15, s16, s17;\n\n    s0 = peg$currPos;\n    s1 = peg$parsewhiteSpace();\n    if (s1 === peg$FAILED) {\n      s1 = null;\n    }\n    if (s1 !== peg$FAILED) {\n      s2 = peg$parsecomments();\n      if (s2 === peg$FAILED) {\n        s2 = null;\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parsewhiteSpace();\n        if (s3 === peg$FAILED) {\n          s3 = null;\n        }\n        if (s3 !== peg$FAILED) {\n          s4 = peg$parsemoveNumber();\n          if (s4 === peg$FAILED) {\n            s4 = null;\n          }\n          if (s4 !== peg$FAILED) {\n            s5 = peg$parsewhiteSpace();\n            if (s5 === peg$FAILED) {\n              s5 = null;\n            }\n            if (s5 !== peg$FAILED) {\n              s6 = peg$parsecomments();\n              if (s6 === peg$FAILED) {\n                s6 = null;\n              }\n              if (s6 !== peg$FAILED) {\n                s7 = peg$parsewhiteSpace();\n                if (s7 === peg$FAILED) {\n                  s7 = null;\n                }\n                if (s7 !== peg$FAILED) {\n                  s8 = peg$parsehalfMove();\n                  if (s8 !== peg$FAILED) {\n                    s9 = peg$parsewhiteSpace();\n                    if (s9 === peg$FAILED) {\n                      s9 = null;\n                    }\n                    if (s9 !== peg$FAILED) {\n                      s10 = peg$parsenags();\n                      if (s10 === peg$FAILED) {\n                        s10 = null;\n                      }\n                      if (s10 !== peg$FAILED) {\n                        s11 = peg$parsewhiteSpace();\n                        if (s11 === peg$FAILED) {\n                          s11 = null;\n                        }\n                        if (s11 !== peg$FAILED) {\n                          s12 = peg$parsecomments();\n                          if (s12 === peg$FAILED) {\n                            s12 = null;\n                          }\n                          if (s12 !== peg$FAILED) {\n                            s13 = peg$parsewhiteSpace();\n                            if (s13 === peg$FAILED) {\n                              s13 = null;\n                            }\n                            if (s13 !== peg$FAILED) {\n                              s14 = peg$parsecommentDiag();\n                              if (s14 === peg$FAILED) {\n                                s14 = null;\n                              }\n                              if (s14 !== peg$FAILED) {\n                                s15 = peg$parsewhiteSpace();\n                                if (s15 === peg$FAILED) {\n                                  s15 = null;\n                                }\n                                if (s15 !== peg$FAILED) {\n                                  s16 = peg$parsevariationBlack();\n                                  if (s16 === peg$FAILED) {\n                                    s16 = null;\n                                  }\n                                  if (s16 !== peg$FAILED) {\n                                    s17 = peg$parsepgnWhite();\n                                    if (s17 === peg$FAILED) {\n                                      s17 = null;\n                                    }\n                                    if (s17 !== peg$FAILED) {\n                                      peg$savedPos = s0;\n                                      s1 = peg$c153(s2, s4, s6, s8, s10, s12, s14, s16, s17);\n                                      s0 = s1;\n                                    } else {\n                                      peg$currPos = s0;\n                                      s0 = peg$FAILED;\n                                    }\n                                  } else {\n                                    peg$currPos = s0;\n                                    s0 = peg$FAILED;\n                                  }\n                                } else {\n                                  peg$currPos = s0;\n                                  s0 = peg$FAILED;\n                                }\n                              } else {\n                                peg$currPos = s0;\n                                s0 = peg$FAILED;\n                              }\n                            } else {\n                              peg$currPos = s0;\n                              s0 = peg$FAILED;\n                            }\n                          } else {\n                            peg$currPos = s0;\n                            s0 = peg$FAILED;\n                          }\n                        } else {\n                          peg$currPos = s0;\n                          s0 = peg$FAILED;\n                        }\n                      } else {\n                        peg$currPos = s0;\n                        s0 = peg$FAILED;\n                      }\n                    } else {\n                      peg$currPos = s0;\n                      s0 = peg$FAILED;\n                    }\n                  } else {\n                    peg$currPos = s0;\n                    s0 = peg$FAILED;\n                  }\n                } else {\n                  peg$currPos = s0;\n                  s0 = peg$FAILED;\n                }\n              } else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n    if (s0 === peg$FAILED) {\n      s0 = peg$parseendGame();\n    }\n\n    return s0;\n  }\n\n  function peg$parseendGame() {\n    var s0, s1, s2;\n\n    s0 = peg$currPos;\n    if (input.substr(peg$currPos, 3) === peg$c134) {\n      s1 = peg$c134;\n      peg$currPos += 3;\n    } else {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c135); }\n    }\n    if (s1 !== peg$FAILED) {\n      s2 = peg$parsewhiteSpace();\n      if (s2 === peg$FAILED) {\n        s2 = null;\n      }\n      if (s2 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s1 = peg$c154();\n        s0 = s1;\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n    if (s0 === peg$FAILED) {\n      s0 = peg$currPos;\n      if (input.substr(peg$currPos, 3) === peg$c138) {\n        s1 = peg$c138;\n        peg$currPos += 3;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c139); }\n      }\n      if (s1 !== peg$FAILED) {\n        s2 = peg$parsewhiteSpace();\n        if (s2 === peg$FAILED) {\n          s2 = null;\n        }\n        if (s2 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s1 = peg$c155();\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n      if (s0 === peg$FAILED) {\n        s0 = peg$currPos;\n        if (input.substr(peg$currPos, 3) === peg$c131) {\n          s1 = peg$c131;\n          peg$currPos += 3;\n        } else {\n          s1 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c132); }\n        }\n        if (s1 !== peg$FAILED) {\n          s2 = peg$parsewhiteSpace();\n          if (s2 === peg$FAILED) {\n            s2 = null;\n          }\n          if (s2 !== peg$FAILED) {\n            peg$savedPos = s0;\n            s1 = peg$c156();\n            s0 = s1;\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n        if (s0 === peg$FAILED) {\n          s0 = peg$currPos;\n          if (input.substr(peg$currPos, 3) === peg$c136) {\n            s1 = peg$c136;\n            peg$currPos += 3;\n          } else {\n            s1 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c137); }\n          }\n          if (s1 !== peg$FAILED) {\n            s2 = peg$parsewhiteSpace();\n            if (s2 === peg$FAILED) {\n              s2 = null;\n            }\n            if (s2 !== peg$FAILED) {\n              peg$savedPos = s0;\n              s1 = peg$c157();\n              s0 = s1;\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n          if (s0 === peg$FAILED) {\n            s0 = peg$currPos;\n            if (input.substr(peg$currPos, 7) === peg$c140) {\n              s1 = peg$c140;\n              peg$currPos += 7;\n            } else {\n              s1 = peg$FAILED;\n              if (peg$silentFails === 0) { peg$fail(peg$c141); }\n            }\n            if (s1 !== peg$FAILED) {\n              s2 = peg$parsewhiteSpace();\n              if (s2 === peg$FAILED) {\n                s2 = null;\n              }\n              if (s2 !== peg$FAILED) {\n                peg$savedPos = s0;\n                s1 = peg$c158();\n                s0 = s1;\n              } else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n            if (s0 === peg$FAILED) {\n              s0 = peg$currPos;\n              if (input.charCodeAt(peg$currPos) === 42) {\n                s1 = peg$c142;\n                peg$currPos++;\n              } else {\n                s1 = peg$FAILED;\n                if (peg$silentFails === 0) { peg$fail(peg$c143); }\n              }\n              if (s1 !== peg$FAILED) {\n                s2 = peg$parsewhiteSpace();\n                if (s2 === peg$FAILED) {\n                  s2 = null;\n                }\n                if (s2 !== peg$FAILED) {\n                  peg$savedPos = s0;\n                  s1 = peg$c159();\n                  s0 = s1;\n                } else {\n                  peg$currPos = s0;\n                  s0 = peg$FAILED;\n                }\n              } else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n              }\n            }\n          }\n        }\n      }\n    }\n\n    return s0;\n  }\n\n  function peg$parsecomments() {\n    var s0, s1, s2, s3, s4, s5;\n\n    s0 = peg$currPos;\n    s1 = peg$parsecomment();\n    if (s1 !== peg$FAILED) {\n      s2 = [];\n      s3 = peg$currPos;\n      s4 = peg$parsewhiteSpace();\n      if (s4 === peg$FAILED) {\n        s4 = null;\n      }\n      if (s4 !== peg$FAILED) {\n        s5 = peg$parsecomment();\n        if (s5 !== peg$FAILED) {\n          s4 = [s4, s5];\n          s3 = s4;\n        } else {\n          peg$currPos = s3;\n          s3 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s3;\n        s3 = peg$FAILED;\n      }\n      while (s3 !== peg$FAILED) {\n        s2.push(s3);\n        s3 = peg$currPos;\n        s4 = peg$parsewhiteSpace();\n        if (s4 === peg$FAILED) {\n          s4 = null;\n        }\n        if (s4 !== peg$FAILED) {\n          s5 = peg$parsecomment();\n          if (s5 !== peg$FAILED) {\n            s4 = [s4, s5];\n            s3 = s4;\n          } else {\n            peg$currPos = s3;\n            s3 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s3;\n          s3 = peg$FAILED;\n        }\n      }\n      if (s2 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s1 = peg$c160(s1, s2);\n        s0 = s1;\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parsecomment() {\n    var s0, s1, s2, s3, s4;\n\n    s0 = peg$currPos;\n    s1 = peg$currPos;\n    peg$silentFails++;\n    s2 = peg$parsecommentDiag();\n    peg$silentFails--;\n    if (s2 === peg$FAILED) {\n      s1 = void 0;\n    } else {\n      peg$currPos = s1;\n      s1 = peg$FAILED;\n    }\n    if (s1 !== peg$FAILED) {\n      s2 = peg$parsecl();\n      if (s2 !== peg$FAILED) {\n        s3 = [];\n        if (peg$c161.test(input.charAt(peg$currPos))) {\n          s4 = input.charAt(peg$currPos);\n          peg$currPos++;\n        } else {\n          s4 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c162); }\n        }\n        if (s4 !== peg$FAILED) {\n          while (s4 !== peg$FAILED) {\n            s3.push(s4);\n            if (peg$c161.test(input.charAt(peg$currPos))) {\n              s4 = input.charAt(peg$currPos);\n              peg$currPos++;\n            } else {\n              s4 = peg$FAILED;\n              if (peg$silentFails === 0) { peg$fail(peg$c162); }\n            }\n          }\n        } else {\n          s3 = peg$FAILED;\n        }\n        if (s3 !== peg$FAILED) {\n          s4 = peg$parsecr();\n          if (s4 !== peg$FAILED) {\n            peg$savedPos = s0;\n            s1 = peg$c163(s3);\n            s0 = s1;\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parsecommentDiag() {\n    var s0, s1, s2, s3, s4, s5;\n\n    s0 = peg$currPos;\n    s1 = peg$parsecl();\n    if (s1 !== peg$FAILED) {\n      s2 = peg$parsewhiteSpace();\n      if (s2 === peg$FAILED) {\n        s2 = null;\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parsecommentAnnotations();\n        if (s3 !== peg$FAILED) {\n          s4 = peg$parsewhiteSpace();\n          if (s4 === peg$FAILED) {\n            s4 = null;\n          }\n          if (s4 !== peg$FAILED) {\n            s5 = peg$parsecr();\n            if (s5 !== peg$FAILED) {\n              peg$savedPos = s0;\n              s1 = peg$c164(s3);\n              s0 = s1;\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parsecommentAnnotations() {\n    var s0, s1, s2, s3, s4;\n\n    s0 = peg$currPos;\n    s1 = peg$parsecommentAnnotation();\n    if (s1 !== peg$FAILED) {\n      s2 = peg$parsewhiteSpace();\n      if (s2 === peg$FAILED) {\n        s2 = null;\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = [];\n        s4 = peg$parsecommentAnnotation();\n        while (s4 !== peg$FAILED) {\n          s3.push(s4);\n          s4 = peg$parsecommentAnnotation();\n        }\n        if (s3 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s1 = peg$c165(s1, s3);\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parsecommentAnnotation() {\n    var s0, s1;\n\n    s0 = peg$currPos;\n    s1 = peg$parsecommentAnnotationFields();\n    if (s1 !== peg$FAILED) {\n      peg$savedPos = s0;\n      s1 = peg$c166(s1);\n    }\n    s0 = s1;\n    if (s0 === peg$FAILED) {\n      s0 = peg$currPos;\n      s1 = peg$parsecommentAnnotationArrows();\n      if (s1 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s1 = peg$c167(s1);\n      }\n      s0 = s1;\n      if (s0 === peg$FAILED) {\n        s0 = peg$currPos;\n        s1 = peg$parsecommentAnnotationClock();\n        if (s1 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s1 = peg$c168(s1);\n        }\n        s0 = s1;\n      }\n    }\n\n    return s0;\n  }\n\n  function peg$parsecommentAnnotationFields() {\n    var s0, s1, s2, s3, s4, s5, s6, s7;\n\n    s0 = peg$currPos;\n    s1 = peg$parsebl();\n    if (s1 !== peg$FAILED) {\n      s2 = peg$parsewhiteSpace();\n      if (s2 === peg$FAILED) {\n        s2 = null;\n      }\n      if (s2 !== peg$FAILED) {\n        if (input.substr(peg$currPos, 4) === peg$c169) {\n          s3 = peg$c169;\n          peg$currPos += 4;\n        } else {\n          s3 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c170); }\n        }\n        if (s3 !== peg$FAILED) {\n          s4 = peg$parsewhiteSpace();\n          if (s4 !== peg$FAILED) {\n            s5 = peg$parsecolorFields();\n            if (s5 !== peg$FAILED) {\n              s6 = peg$parsewhiteSpace();\n              if (s6 === peg$FAILED) {\n                s6 = null;\n              }\n              if (s6 !== peg$FAILED) {\n                s7 = peg$parsebr();\n                if (s7 !== peg$FAILED) {\n                  peg$savedPos = s0;\n                  s1 = peg$c171(s5);\n                  s0 = s1;\n                } else {\n                  peg$currPos = s0;\n                  s0 = peg$FAILED;\n                }\n              } else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parsecommentAnnotationArrows() {\n    var s0, s1, s2, s3, s4, s5, s6, s7;\n\n    s0 = peg$currPos;\n    s1 = peg$parsebl();\n    if (s1 !== peg$FAILED) {\n      s2 = peg$parsewhiteSpace();\n      if (s2 === peg$FAILED) {\n        s2 = null;\n      }\n      if (s2 !== peg$FAILED) {\n        if (input.substr(peg$currPos, 4) === peg$c172) {\n          s3 = peg$c172;\n          peg$currPos += 4;\n        } else {\n          s3 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c173); }\n        }\n        if (s3 !== peg$FAILED) {\n          s4 = peg$parsewhiteSpace();\n          if (s4 !== peg$FAILED) {\n            s5 = peg$parsecolorArrows();\n            if (s5 !== peg$FAILED) {\n              s6 = peg$parsewhiteSpace();\n              if (s6 === peg$FAILED) {\n                s6 = null;\n              }\n              if (s6 !== peg$FAILED) {\n                s7 = peg$parsebr();\n                if (s7 !== peg$FAILED) {\n                  peg$savedPos = s0;\n                  s1 = peg$c171(s5);\n                  s0 = s1;\n                } else {\n                  peg$currPos = s0;\n                  s0 = peg$FAILED;\n                }\n              } else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parsecolorFields() {\n    var s0, s1, s2, s3, s4, s5, s6, s7;\n\n    s0 = peg$currPos;\n    s1 = peg$parsecolorField();\n    if (s1 !== peg$FAILED) {\n      s2 = peg$parsewhiteSpace();\n      if (s2 === peg$FAILED) {\n        s2 = null;\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = [];\n        s4 = peg$currPos;\n        if (input.charCodeAt(peg$currPos) === 44) {\n          s5 = peg$c174;\n          peg$currPos++;\n        } else {\n          s5 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c175); }\n        }\n        if (s5 !== peg$FAILED) {\n          s6 = peg$parsewhiteSpace();\n          if (s6 === peg$FAILED) {\n            s6 = null;\n          }\n          if (s6 !== peg$FAILED) {\n            s7 = peg$parsecolorField();\n            if (s7 !== peg$FAILED) {\n              s5 = [s5, s6, s7];\n              s4 = s5;\n            } else {\n              peg$currPos = s4;\n              s4 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s4;\n            s4 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s4;\n          s4 = peg$FAILED;\n        }\n        while (s4 !== peg$FAILED) {\n          s3.push(s4);\n          s4 = peg$currPos;\n          if (input.charCodeAt(peg$currPos) === 44) {\n            s5 = peg$c174;\n            peg$currPos++;\n          } else {\n            s5 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c175); }\n          }\n          if (s5 !== peg$FAILED) {\n            s6 = peg$parsewhiteSpace();\n            if (s6 === peg$FAILED) {\n              s6 = null;\n            }\n            if (s6 !== peg$FAILED) {\n              s7 = peg$parsecolorField();\n              if (s7 !== peg$FAILED) {\n                s5 = [s5, s6, s7];\n                s4 = s5;\n              } else {\n                peg$currPos = s4;\n                s4 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s4;\n              s4 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s4;\n            s4 = peg$FAILED;\n          }\n        }\n        if (s3 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s1 = peg$c176(s1, s3);\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parsecolorField() {\n    var s0, s1, s2;\n\n    s0 = peg$currPos;\n    s1 = peg$parsecolor();\n    if (s1 !== peg$FAILED) {\n      s2 = peg$parsefield();\n      if (s2 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s1 = peg$c177(s1, s2);\n        s0 = s1;\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parsecolorArrows() {\n    var s0, s1, s2, s3, s4, s5, s6, s7;\n\n    s0 = peg$currPos;\n    s1 = peg$parsecolorArrow();\n    if (s1 !== peg$FAILED) {\n      s2 = peg$parsewhiteSpace();\n      if (s2 === peg$FAILED) {\n        s2 = null;\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = [];\n        s4 = peg$currPos;\n        if (input.charCodeAt(peg$currPos) === 44) {\n          s5 = peg$c174;\n          peg$currPos++;\n        } else {\n          s5 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c175); }\n        }\n        if (s5 !== peg$FAILED) {\n          s6 = peg$parsewhiteSpace();\n          if (s6 === peg$FAILED) {\n            s6 = null;\n          }\n          if (s6 !== peg$FAILED) {\n            s7 = peg$parsecolorArrow();\n            if (s7 !== peg$FAILED) {\n              s5 = [s5, s6, s7];\n              s4 = s5;\n            } else {\n              peg$currPos = s4;\n              s4 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s4;\n            s4 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s4;\n          s4 = peg$FAILED;\n        }\n        while (s4 !== peg$FAILED) {\n          s3.push(s4);\n          s4 = peg$currPos;\n          if (input.charCodeAt(peg$currPos) === 44) {\n            s5 = peg$c174;\n            peg$currPos++;\n          } else {\n            s5 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c175); }\n          }\n          if (s5 !== peg$FAILED) {\n            s6 = peg$parsewhiteSpace();\n            if (s6 === peg$FAILED) {\n              s6 = null;\n            }\n            if (s6 !== peg$FAILED) {\n              s7 = peg$parsecolorArrow();\n              if (s7 !== peg$FAILED) {\n                s5 = [s5, s6, s7];\n                s4 = s5;\n              } else {\n                peg$currPos = s4;\n                s4 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s4;\n              s4 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s4;\n            s4 = peg$FAILED;\n          }\n        }\n        if (s3 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s1 = peg$c176(s1, s3);\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parsecolorArrow() {\n    var s0, s1, s2, s3;\n\n    s0 = peg$currPos;\n    s1 = peg$parsecolor();\n    if (s1 !== peg$FAILED) {\n      s2 = peg$parsefield();\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parsefield();\n        if (s3 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s1 = peg$c178(s1, s2, s3);\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parsecolor() {\n    var s0, s1;\n\n    s0 = peg$currPos;\n    if (input.charCodeAt(peg$currPos) === 89) {\n      s1 = peg$c179;\n      peg$currPos++;\n    } else {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c180); }\n    }\n    if (s1 !== peg$FAILED) {\n      peg$savedPos = s0;\n      s1 = peg$c181();\n    }\n    s0 = s1;\n    if (s0 === peg$FAILED) {\n      s0 = peg$currPos;\n      if (input.charCodeAt(peg$currPos) === 71) {\n        s1 = peg$c182;\n        peg$currPos++;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c183); }\n      }\n      if (s1 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s1 = peg$c184();\n      }\n      s0 = s1;\n      if (s0 === peg$FAILED) {\n        s0 = peg$currPos;\n        if (input.charCodeAt(peg$currPos) === 82) {\n          s1 = peg$c185;\n          peg$currPos++;\n        } else {\n          s1 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c186); }\n        }\n        if (s1 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s1 = peg$c187();\n        }\n        s0 = s1;\n        if (s0 === peg$FAILED) {\n          s0 = peg$currPos;\n          if (input.charCodeAt(peg$currPos) === 66) {\n            s1 = peg$c188;\n            peg$currPos++;\n          } else {\n            s1 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c189); }\n          }\n          if (s1 !== peg$FAILED) {\n            peg$savedPos = s0;\n            s1 = peg$c190();\n          }\n          s0 = s1;\n        }\n      }\n    }\n\n    return s0;\n  }\n\n  function peg$parsefield() {\n    var s0, s1, s2;\n\n    s0 = peg$currPos;\n    s1 = peg$parsecolumn();\n    if (s1 !== peg$FAILED) {\n      s2 = peg$parserow();\n      if (s2 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s1 = peg$c191(s1, s2);\n        s0 = s1;\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parsecl() {\n    var s0;\n\n    if (input.charCodeAt(peg$currPos) === 123) {\n      s0 = peg$c192;\n      peg$currPos++;\n    } else {\n      s0 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c193); }\n    }\n\n    return s0;\n  }\n\n  function peg$parsecr() {\n    var s0;\n\n    if (input.charCodeAt(peg$currPos) === 125) {\n      s0 = peg$c194;\n      peg$currPos++;\n    } else {\n      s0 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c195); }\n    }\n\n    return s0;\n  }\n\n  function peg$parsebl() {\n    var s0;\n\n    if (input.charCodeAt(peg$currPos) === 91) {\n      s0 = peg$c196;\n      peg$currPos++;\n    } else {\n      s0 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c197); }\n    }\n\n    return s0;\n  }\n\n  function peg$parsebr() {\n    var s0;\n\n    if (input.charCodeAt(peg$currPos) === 93) {\n      s0 = peg$c198;\n      peg$currPos++;\n    } else {\n      s0 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c199); }\n    }\n\n    return s0;\n  }\n\n  function peg$parsecommentAnnotationClock() {\n    var s0, s1, s2, s3, s4, s5, s6, s7, s8;\n\n    s0 = peg$currPos;\n    s1 = peg$parsebl();\n    if (s1 !== peg$FAILED) {\n      s2 = peg$parsewhiteSpace();\n      if (s2 === peg$FAILED) {\n        s2 = null;\n      }\n      if (s2 !== peg$FAILED) {\n        if (input.charCodeAt(peg$currPos) === 37) {\n          s3 = peg$c200;\n          peg$currPos++;\n        } else {\n          s3 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c201); }\n        }\n        if (s3 !== peg$FAILED) {\n          s4 = peg$parseclockCommand();\n          if (s4 !== peg$FAILED) {\n            s5 = peg$parsewhiteSpace();\n            if (s5 !== peg$FAILED) {\n              s6 = peg$parseclockValue();\n              if (s6 !== peg$FAILED) {\n                s7 = peg$parsewhiteSpace();\n                if (s7 === peg$FAILED) {\n                  s7 = null;\n                }\n                if (s7 !== peg$FAILED) {\n                  s8 = peg$parsebr();\n                  if (s8 !== peg$FAILED) {\n                    peg$savedPos = s0;\n                    s1 = peg$c202(s4, s6);\n                    s0 = s1;\n                  } else {\n                    peg$currPos = s0;\n                    s0 = peg$FAILED;\n                  }\n                } else {\n                  peg$currPos = s0;\n                  s0 = peg$FAILED;\n                }\n              } else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parseclockCommand() {\n    var s0, s1;\n\n    s0 = peg$currPos;\n    if (input.substr(peg$currPos, 3) === peg$c203) {\n      s1 = peg$c203;\n      peg$currPos += 3;\n    } else {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c204); }\n    }\n    if (s1 !== peg$FAILED) {\n      peg$savedPos = s0;\n      s1 = peg$c205();\n    }\n    s0 = s1;\n    if (s0 === peg$FAILED) {\n      s0 = peg$currPos;\n      if (input.substr(peg$currPos, 3) === peg$c206) {\n        s1 = peg$c206;\n        peg$currPos += 3;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c207); }\n      }\n      if (s1 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s1 = peg$c208();\n      }\n      s0 = s1;\n      if (s0 === peg$FAILED) {\n        s0 = peg$currPos;\n        if (input.substr(peg$currPos, 3) === peg$c209) {\n          s1 = peg$c209;\n          peg$currPos += 3;\n        } else {\n          s1 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c210); }\n        }\n        if (s1 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s1 = peg$c211();\n        }\n        s0 = s1;\n        if (s0 === peg$FAILED) {\n          s0 = peg$currPos;\n          if (input.substr(peg$currPos, 3) === peg$c212) {\n            s1 = peg$c212;\n            peg$currPos += 3;\n          } else {\n            s1 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c213); }\n          }\n          if (s1 !== peg$FAILED) {\n            peg$savedPos = s0;\n            s1 = peg$c214();\n          }\n          s0 = s1;\n        }\n      }\n    }\n\n    return s0;\n  }\n\n  function peg$parseclockValue() {\n    var s0, s1, s2, s3, s4, s5, s6, s7, s8;\n\n    s0 = peg$currPos;\n    s1 = peg$parsedigit();\n    if (s1 !== peg$FAILED) {\n      s2 = peg$parsedigit();\n      if (s2 === peg$FAILED) {\n        s2 = null;\n      }\n      if (s2 !== peg$FAILED) {\n        if (input.charCodeAt(peg$currPos) === 58) {\n          s3 = peg$c215;\n          peg$currPos++;\n        } else {\n          s3 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c216); }\n        }\n        if (s3 !== peg$FAILED) {\n          s4 = peg$parsedigit();\n          if (s4 !== peg$FAILED) {\n            s5 = peg$parsedigit();\n            if (s5 !== peg$FAILED) {\n              if (input.charCodeAt(peg$currPos) === 58) {\n                s6 = peg$c215;\n                peg$currPos++;\n              } else {\n                s6 = peg$FAILED;\n                if (peg$silentFails === 0) { peg$fail(peg$c216); }\n              }\n              if (s6 !== peg$FAILED) {\n                s7 = peg$parsedigit();\n                if (s7 !== peg$FAILED) {\n                  s8 = peg$parsedigit();\n                  if (s8 !== peg$FAILED) {\n                    peg$savedPos = s0;\n                    s1 = peg$c217(s1, s2, s4, s5, s7, s8);\n                    s0 = s1;\n                  } else {\n                    peg$currPos = s0;\n                    s0 = peg$FAILED;\n                  }\n                } else {\n                  peg$currPos = s0;\n                  s0 = peg$FAILED;\n                }\n              } else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parsedigit() {\n    var s0, s1;\n\n    s0 = peg$currPos;\n    if (peg$c125.test(input.charAt(peg$currPos))) {\n      s1 = input.charAt(peg$currPos);\n      peg$currPos++;\n    } else {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c126); }\n    }\n    if (s1 !== peg$FAILED) {\n      peg$savedPos = s0;\n      s1 = peg$c218(s1);\n    }\n    s0 = s1;\n\n    return s0;\n  }\n\n  function peg$parsevariationWhite() {\n    var s0, s1, s2, s3, s4, s5, s6, s7;\n\n    s0 = peg$currPos;\n    s1 = peg$parsepl();\n    if (s1 !== peg$FAILED) {\n      s2 = peg$parsepgnWhite();\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parsepr();\n        if (s3 !== peg$FAILED) {\n          s4 = peg$parsewhiteSpace();\n          if (s4 === peg$FAILED) {\n            s4 = null;\n          }\n          if (s4 !== peg$FAILED) {\n            s5 = peg$parsevariationWhite();\n            if (s5 === peg$FAILED) {\n              s5 = null;\n            }\n            if (s5 !== peg$FAILED) {\n              s6 = peg$parsewhiteSpace();\n              if (s6 === peg$FAILED) {\n                s6 = null;\n              }\n              if (s6 !== peg$FAILED) {\n                s7 = peg$parsemoveNumber();\n                if (s7 === peg$FAILED) {\n                  s7 = null;\n                }\n                if (s7 !== peg$FAILED) {\n                  peg$savedPos = s0;\n                  s1 = peg$c219(s2, s5, s7);\n                  s0 = s1;\n                } else {\n                  peg$currPos = s0;\n                  s0 = peg$FAILED;\n                }\n              } else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parsevariationBlack() {\n    var s0, s1, s2, s3, s4, s5;\n\n    s0 = peg$currPos;\n    s1 = peg$parsepl();\n    if (s1 !== peg$FAILED) {\n      s2 = peg$parsepgnStartBlack();\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parsepr();\n        if (s3 !== peg$FAILED) {\n          s4 = peg$parsewhiteSpace();\n          if (s4 === peg$FAILED) {\n            s4 = null;\n          }\n          if (s4 !== peg$FAILED) {\n            s5 = peg$parsevariationBlack();\n            if (s5 === peg$FAILED) {\n              s5 = null;\n            }\n            if (s5 !== peg$FAILED) {\n              peg$savedPos = s0;\n              s1 = peg$c220(s2, s5);\n              s0 = s1;\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parsepl() {\n    var s0;\n\n    if (input.charCodeAt(peg$currPos) === 40) {\n      s0 = peg$c221;\n      peg$currPos++;\n    } else {\n      s0 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c222); }\n    }\n\n    return s0;\n  }\n\n  function peg$parsepr() {\n    var s0;\n\n    if (input.charCodeAt(peg$currPos) === 41) {\n      s0 = peg$c223;\n      peg$currPos++;\n    } else {\n      s0 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c224); }\n    }\n\n    return s0;\n  }\n\n  function peg$parsemoveNumber() {\n    var s0, s1, s2, s3;\n\n    s0 = peg$currPos;\n    s1 = peg$parseinteger();\n    if (s1 !== peg$FAILED) {\n      s2 = [];\n      s3 = peg$parsedotOrWhitespace();\n      while (s3 !== peg$FAILED) {\n        s2.push(s3);\n        s3 = peg$parsedotOrWhitespace();\n      }\n      if (s2 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s1 = peg$c225(s1);\n        s0 = s1;\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parsedot() {\n    var s0;\n\n    if (input.charCodeAt(peg$currPos) === 46) {\n      s0 = peg$c127;\n      peg$currPos++;\n    } else {\n      s0 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c128); }\n    }\n\n    return s0;\n  }\n\n  function peg$parseinteger() {\n    var s0, s1, s2;\n\n    peg$silentFails++;\n    s0 = peg$currPos;\n    s1 = [];\n    if (peg$c125.test(input.charAt(peg$currPos))) {\n      s2 = input.charAt(peg$currPos);\n      peg$currPos++;\n    } else {\n      s2 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c126); }\n    }\n    if (s2 !== peg$FAILED) {\n      while (s2 !== peg$FAILED) {\n        s1.push(s2);\n        if (peg$c125.test(input.charAt(peg$currPos))) {\n          s2 = input.charAt(peg$currPos);\n          peg$currPos++;\n        } else {\n          s2 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c126); }\n        }\n      }\n    } else {\n      s1 = peg$FAILED;\n    }\n    if (s1 !== peg$FAILED) {\n      peg$savedPos = s0;\n      s1 = peg$c146(s1);\n    }\n    s0 = s1;\n    peg$silentFails--;\n    if (s0 === peg$FAILED) {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c226); }\n    }\n\n    return s0;\n  }\n\n  function peg$parsewhiteSpace() {\n    var s0, s1, s2;\n\n    s0 = peg$currPos;\n    s1 = [];\n    if (input.charCodeAt(peg$currPos) === 32) {\n      s2 = peg$c227;\n      peg$currPos++;\n    } else {\n      s2 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c228); }\n    }\n    if (s2 !== peg$FAILED) {\n      while (s2 !== peg$FAILED) {\n        s1.push(s2);\n        if (input.charCodeAt(peg$currPos) === 32) {\n          s2 = peg$c227;\n          peg$currPos++;\n        } else {\n          s2 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c228); }\n        }\n      }\n    } else {\n      s1 = peg$FAILED;\n    }\n    if (s1 !== peg$FAILED) {\n      peg$savedPos = s0;\n      s1 = peg$c229();\n    }\n    s0 = s1;\n\n    return s0;\n  }\n\n  function peg$parsedotOrWhitespace() {\n    var s0;\n\n    s0 = peg$parsedot();\n    if (s0 === peg$FAILED) {\n      s0 = peg$parsewhiteSpace();\n    }\n\n    return s0;\n  }\n\n  function peg$parsehalfMove() {\n    var s0, s1, s2, s3, s4, s5, s6, s7, s8;\n\n    s0 = peg$currPos;\n    s1 = peg$parsefigure();\n    if (s1 === peg$FAILED) {\n      s1 = null;\n    }\n    if (s1 !== peg$FAILED) {\n      s2 = peg$currPos;\n      peg$silentFails++;\n      s3 = peg$parsecheckdisc();\n      peg$silentFails--;\n      if (s3 !== peg$FAILED) {\n        peg$currPos = s2;\n        s2 = void 0;\n      } else {\n        s2 = peg$FAILED;\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parsediscriminator();\n        if (s3 !== peg$FAILED) {\n          s4 = peg$parsestrike();\n          if (s4 === peg$FAILED) {\n            s4 = null;\n          }\n          if (s4 !== peg$FAILED) {\n            s5 = peg$parsecolumn();\n            if (s5 !== peg$FAILED) {\n              s6 = peg$parserow();\n              if (s6 !== peg$FAILED) {\n                s7 = peg$parsepromotion();\n                if (s7 === peg$FAILED) {\n                  s7 = null;\n                }\n                if (s7 !== peg$FAILED) {\n                  s8 = peg$parsecheck();\n                  if (s8 === peg$FAILED) {\n                    s8 = null;\n                  }\n                  if (s8 !== peg$FAILED) {\n                    peg$savedPos = s0;\n                    s1 = peg$c230(s1, s3, s4, s5, s6, s7, s8);\n                    s0 = s1;\n                  } else {\n                    peg$currPos = s0;\n                    s0 = peg$FAILED;\n                  }\n                } else {\n                  peg$currPos = s0;\n                  s0 = peg$FAILED;\n                }\n              } else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n    if (s0 === peg$FAILED) {\n      s0 = peg$currPos;\n      s1 = peg$parsefigure();\n      if (s1 === peg$FAILED) {\n        s1 = null;\n      }\n      if (s1 !== peg$FAILED) {\n        s2 = peg$parsecolumn();\n        if (s2 !== peg$FAILED) {\n          s3 = peg$parserow();\n          if (s3 !== peg$FAILED) {\n            s4 = peg$parsestrikeOrDash();\n            if (s4 === peg$FAILED) {\n              s4 = null;\n            }\n            if (s4 !== peg$FAILED) {\n              s5 = peg$parsecolumn();\n              if (s5 !== peg$FAILED) {\n                s6 = peg$parserow();\n                if (s6 !== peg$FAILED) {\n                  s7 = peg$parsepromotion();\n                  if (s7 === peg$FAILED) {\n                    s7 = null;\n                  }\n                  if (s7 !== peg$FAILED) {\n                    s8 = peg$parsecheck();\n                    if (s8 === peg$FAILED) {\n                      s8 = null;\n                    }\n                    if (s8 !== peg$FAILED) {\n                      peg$savedPos = s0;\n                      s1 = peg$c231(s1, s2, s3, s4, s5, s6, s7, s8);\n                      s0 = s1;\n                    } else {\n                      peg$currPos = s0;\n                      s0 = peg$FAILED;\n                    }\n                  } else {\n                    peg$currPos = s0;\n                    s0 = peg$FAILED;\n                  }\n                } else {\n                  peg$currPos = s0;\n                  s0 = peg$FAILED;\n                }\n              } else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n      if (s0 === peg$FAILED) {\n        s0 = peg$currPos;\n        s1 = peg$parsefigure();\n        if (s1 === peg$FAILED) {\n          s1 = null;\n        }\n        if (s1 !== peg$FAILED) {\n          s2 = peg$parsestrike();\n          if (s2 === peg$FAILED) {\n            s2 = null;\n          }\n          if (s2 !== peg$FAILED) {\n            s3 = peg$parsecolumn();\n            if (s3 !== peg$FAILED) {\n              s4 = peg$parserow();\n              if (s4 !== peg$FAILED) {\n                s5 = peg$parsepromotion();\n                if (s5 === peg$FAILED) {\n                  s5 = null;\n                }\n                if (s5 !== peg$FAILED) {\n                  s6 = peg$parsecheck();\n                  if (s6 === peg$FAILED) {\n                    s6 = null;\n                  }\n                  if (s6 !== peg$FAILED) {\n                    peg$savedPos = s0;\n                    s1 = peg$c232(s1, s2, s3, s4, s5, s6);\n                    s0 = s1;\n                  } else {\n                    peg$currPos = s0;\n                    s0 = peg$FAILED;\n                  }\n                } else {\n                  peg$currPos = s0;\n                  s0 = peg$FAILED;\n                }\n              } else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n        if (s0 === peg$FAILED) {\n          s0 = peg$currPos;\n          if (input.substr(peg$currPos, 5) === peg$c233) {\n            s1 = peg$c233;\n            peg$currPos += 5;\n          } else {\n            s1 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c234); }\n          }\n          if (s1 !== peg$FAILED) {\n            s2 = peg$parsecheck();\n            if (s2 === peg$FAILED) {\n              s2 = null;\n            }\n            if (s2 !== peg$FAILED) {\n              peg$savedPos = s0;\n              s1 = peg$c235(s2);\n              s0 = s1;\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n          if (s0 === peg$FAILED) {\n            s0 = peg$currPos;\n            if (input.substr(peg$currPos, 3) === peg$c236) {\n              s1 = peg$c236;\n              peg$currPos += 3;\n            } else {\n              s1 = peg$FAILED;\n              if (peg$silentFails === 0) { peg$fail(peg$c237); }\n            }\n            if (s1 !== peg$FAILED) {\n              s2 = peg$parsecheck();\n              if (s2 === peg$FAILED) {\n                s2 = null;\n              }\n              if (s2 !== peg$FAILED) {\n                peg$savedPos = s0;\n                s1 = peg$c238(s2);\n                s0 = s1;\n              } else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          }\n        }\n      }\n    }\n\n    return s0;\n  }\n\n  function peg$parsecheck() {\n    var s0, s1, s2, s3;\n\n    s0 = peg$currPos;\n    s1 = peg$currPos;\n    s2 = peg$currPos;\n    peg$silentFails++;\n    if (input.substr(peg$currPos, 2) === peg$c239) {\n      s3 = peg$c239;\n      peg$currPos += 2;\n    } else {\n      s3 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c240); }\n    }\n    peg$silentFails--;\n    if (s3 === peg$FAILED) {\n      s2 = void 0;\n    } else {\n      peg$currPos = s2;\n      s2 = peg$FAILED;\n    }\n    if (s2 !== peg$FAILED) {\n      if (input.charCodeAt(peg$currPos) === 43) {\n        s3 = peg$c241;\n        peg$currPos++;\n      } else {\n        s3 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c242); }\n      }\n      if (s3 !== peg$FAILED) {\n        s2 = [s2, s3];\n        s1 = s2;\n      } else {\n        peg$currPos = s1;\n        s1 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s1;\n      s1 = peg$FAILED;\n    }\n    if (s1 !== peg$FAILED) {\n      peg$savedPos = s0;\n      s1 = peg$c243(s1);\n    }\n    s0 = s1;\n    if (s0 === peg$FAILED) {\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = peg$currPos;\n      peg$silentFails++;\n      if (input.substr(peg$currPos, 3) === peg$c244) {\n        s3 = peg$c244;\n        peg$currPos += 3;\n      } else {\n        s3 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c245); }\n      }\n      peg$silentFails--;\n      if (s3 === peg$FAILED) {\n        s2 = void 0;\n      } else {\n        peg$currPos = s2;\n        s2 = peg$FAILED;\n      }\n      if (s2 !== peg$FAILED) {\n        if (input.charCodeAt(peg$currPos) === 35) {\n          s3 = peg$c246;\n          peg$currPos++;\n        } else {\n          s3 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c247); }\n        }\n        if (s3 !== peg$FAILED) {\n          s2 = [s2, s3];\n          s1 = s2;\n        } else {\n          peg$currPos = s1;\n          s1 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$FAILED;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s1 = peg$c243(s1);\n      }\n      s0 = s1;\n    }\n\n    return s0;\n  }\n\n  function peg$parsepromotion() {\n    var s0, s1, s2;\n\n    s0 = peg$currPos;\n    if (input.charCodeAt(peg$currPos) === 61) {\n      s1 = peg$c248;\n      peg$currPos++;\n    } else {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c249); }\n    }\n    if (s1 !== peg$FAILED) {\n      s2 = peg$parsepromFigure();\n      if (s2 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s1 = peg$c250(s2);\n        s0 = s1;\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parsenags() {\n    var s0, s1, s2, s3;\n\n    s0 = peg$currPos;\n    s1 = peg$parsenag();\n    if (s1 !== peg$FAILED) {\n      s2 = peg$parsewhiteSpace();\n      if (s2 === peg$FAILED) {\n        s2 = null;\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parsenags();\n        if (s3 === peg$FAILED) {\n          s3 = null;\n        }\n        if (s3 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s1 = peg$c251(s1, s3);\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parsenag() {\n    var s0, s1, s2;\n\n    s0 = peg$currPos;\n    if (input.charCodeAt(peg$currPos) === 36) {\n      s1 = peg$c252;\n      peg$currPos++;\n    } else {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c253); }\n    }\n    if (s1 !== peg$FAILED) {\n      s2 = peg$parseinteger();\n      if (s2 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s1 = peg$c254(s2);\n        s0 = s1;\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n    if (s0 === peg$FAILED) {\n      s0 = peg$currPos;\n      if (input.substr(peg$currPos, 2) === peg$c255) {\n        s1 = peg$c255;\n        peg$currPos += 2;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c256); }\n      }\n      if (s1 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s1 = peg$c257();\n      }\n      s0 = s1;\n      if (s0 === peg$FAILED) {\n        s0 = peg$currPos;\n        if (input.substr(peg$currPos, 2) === peg$c258) {\n          s1 = peg$c258;\n          peg$currPos += 2;\n        } else {\n          s1 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c259); }\n        }\n        if (s1 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s1 = peg$c260();\n        }\n        s0 = s1;\n        if (s0 === peg$FAILED) {\n          s0 = peg$currPos;\n          if (input.substr(peg$currPos, 2) === peg$c261) {\n            s1 = peg$c261;\n            peg$currPos += 2;\n          } else {\n            s1 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c262); }\n          }\n          if (s1 !== peg$FAILED) {\n            peg$savedPos = s0;\n            s1 = peg$c263();\n          }\n          s0 = s1;\n          if (s0 === peg$FAILED) {\n            s0 = peg$currPos;\n            if (input.substr(peg$currPos, 2) === peg$c264) {\n              s1 = peg$c264;\n              peg$currPos += 2;\n            } else {\n              s1 = peg$FAILED;\n              if (peg$silentFails === 0) { peg$fail(peg$c265); }\n            }\n            if (s1 !== peg$FAILED) {\n              peg$savedPos = s0;\n              s1 = peg$c266();\n            }\n            s0 = s1;\n            if (s0 === peg$FAILED) {\n              s0 = peg$currPos;\n              if (input.charCodeAt(peg$currPos) === 33) {\n                s1 = peg$c267;\n                peg$currPos++;\n              } else {\n                s1 = peg$FAILED;\n                if (peg$silentFails === 0) { peg$fail(peg$c268); }\n              }\n              if (s1 !== peg$FAILED) {\n                peg$savedPos = s0;\n                s1 = peg$c269();\n              }\n              s0 = s1;\n              if (s0 === peg$FAILED) {\n                s0 = peg$currPos;\n                if (input.charCodeAt(peg$currPos) === 63) {\n                  s1 = peg$c270;\n                  peg$currPos++;\n                } else {\n                  s1 = peg$FAILED;\n                  if (peg$silentFails === 0) { peg$fail(peg$c271); }\n                }\n                if (s1 !== peg$FAILED) {\n                  peg$savedPos = s0;\n                  s1 = peg$c272();\n                }\n                s0 = s1;\n                if (s0 === peg$FAILED) {\n                  s0 = peg$currPos;\n                  if (input.charCodeAt(peg$currPos) === 8252) {\n                    s1 = peg$c273;\n                    peg$currPos++;\n                  } else {\n                    s1 = peg$FAILED;\n                    if (peg$silentFails === 0) { peg$fail(peg$c274); }\n                  }\n                  if (s1 !== peg$FAILED) {\n                    peg$savedPos = s0;\n                    s1 = peg$c257();\n                  }\n                  s0 = s1;\n                  if (s0 === peg$FAILED) {\n                    s0 = peg$currPos;\n                    if (input.charCodeAt(peg$currPos) === 8263) {\n                      s1 = peg$c275;\n                      peg$currPos++;\n                    } else {\n                      s1 = peg$FAILED;\n                      if (peg$silentFails === 0) { peg$fail(peg$c276); }\n                    }\n                    if (s1 !== peg$FAILED) {\n                      peg$savedPos = s0;\n                      s1 = peg$c260();\n                    }\n                    s0 = s1;\n                    if (s0 === peg$FAILED) {\n                      s0 = peg$currPos;\n                      if (input.charCodeAt(peg$currPos) === 8265) {\n                        s1 = peg$c277;\n                        peg$currPos++;\n                      } else {\n                        s1 = peg$FAILED;\n                        if (peg$silentFails === 0) { peg$fail(peg$c278); }\n                      }\n                      if (s1 !== peg$FAILED) {\n                        peg$savedPos = s0;\n                        s1 = peg$c263();\n                      }\n                      s0 = s1;\n                      if (s0 === peg$FAILED) {\n                        s0 = peg$currPos;\n                        if (input.charCodeAt(peg$currPos) === 8264) {\n                          s1 = peg$c279;\n                          peg$currPos++;\n                        } else {\n                          s1 = peg$FAILED;\n                          if (peg$silentFails === 0) { peg$fail(peg$c280); }\n                        }\n                        if (s1 !== peg$FAILED) {\n                          peg$savedPos = s0;\n                          s1 = peg$c266();\n                        }\n                        s0 = s1;\n                        if (s0 === peg$FAILED) {\n                          s0 = peg$currPos;\n                          if (input.charCodeAt(peg$currPos) === 9633) {\n                            s1 = peg$c281;\n                            peg$currPos++;\n                          } else {\n                            s1 = peg$FAILED;\n                            if (peg$silentFails === 0) { peg$fail(peg$c282); }\n                          }\n                          if (s1 !== peg$FAILED) {\n                            peg$savedPos = s0;\n                            s1 = peg$c283();\n                          }\n                          s0 = s1;\n                          if (s0 === peg$FAILED) {\n                            s0 = peg$currPos;\n                            if (input.charCodeAt(peg$currPos) === 61) {\n                              s1 = peg$c248;\n                              peg$currPos++;\n                            } else {\n                              s1 = peg$FAILED;\n                              if (peg$silentFails === 0) { peg$fail(peg$c249); }\n                            }\n                            if (s1 !== peg$FAILED) {\n                              peg$savedPos = s0;\n                              s1 = peg$c284();\n                            }\n                            s0 = s1;\n                            if (s0 === peg$FAILED) {\n                              s0 = peg$currPos;\n                              if (input.charCodeAt(peg$currPos) === 8734) {\n                                s1 = peg$c285;\n                                peg$currPos++;\n                              } else {\n                                s1 = peg$FAILED;\n                                if (peg$silentFails === 0) { peg$fail(peg$c286); }\n                              }\n                              if (s1 !== peg$FAILED) {\n                                peg$savedPos = s0;\n                                s1 = peg$c287();\n                              }\n                              s0 = s1;\n                              if (s0 === peg$FAILED) {\n                                s0 = peg$currPos;\n                                if (input.charCodeAt(peg$currPos) === 10866) {\n                                  s1 = peg$c288;\n                                  peg$currPos++;\n                                } else {\n                                  s1 = peg$FAILED;\n                                  if (peg$silentFails === 0) { peg$fail(peg$c289); }\n                                }\n                                if (s1 !== peg$FAILED) {\n                                  peg$savedPos = s0;\n                                  s1 = peg$c290();\n                                }\n                                s0 = s1;\n                                if (s0 === peg$FAILED) {\n                                  s0 = peg$currPos;\n                                  if (input.charCodeAt(peg$currPos) === 10865) {\n                                    s1 = peg$c291;\n                                    peg$currPos++;\n                                  } else {\n                                    s1 = peg$FAILED;\n                                    if (peg$silentFails === 0) { peg$fail(peg$c292); }\n                                  }\n                                  if (s1 !== peg$FAILED) {\n                                    peg$savedPos = s0;\n                                    s1 = peg$c293();\n                                  }\n                                  s0 = s1;\n                                  if (s0 === peg$FAILED) {\n                                    s0 = peg$currPos;\n                                    if (input.charCodeAt(peg$currPos) === 177) {\n                                      s1 = peg$c294;\n                                      peg$currPos++;\n                                    } else {\n                                      s1 = peg$FAILED;\n                                      if (peg$silentFails === 0) { peg$fail(peg$c295); }\n                                    }\n                                    if (s1 !== peg$FAILED) {\n                                      peg$savedPos = s0;\n                                      s1 = peg$c296();\n                                    }\n                                    s0 = s1;\n                                    if (s0 === peg$FAILED) {\n                                      s0 = peg$currPos;\n                                      if (input.charCodeAt(peg$currPos) === 8723) {\n                                        s1 = peg$c297;\n                                        peg$currPos++;\n                                      } else {\n                                        s1 = peg$FAILED;\n                                        if (peg$silentFails === 0) { peg$fail(peg$c298); }\n                                      }\n                                      if (s1 !== peg$FAILED) {\n                                        peg$savedPos = s0;\n                                        s1 = peg$c299();\n                                      }\n                                      s0 = s1;\n                                      if (s0 === peg$FAILED) {\n                                        s0 = peg$currPos;\n                                        if (input.substr(peg$currPos, 2) === peg$c239) {\n                                          s1 = peg$c239;\n                                          peg$currPos += 2;\n                                        } else {\n                                          s1 = peg$FAILED;\n                                          if (peg$silentFails === 0) { peg$fail(peg$c240); }\n                                        }\n                                        if (s1 !== peg$FAILED) {\n                                          peg$savedPos = s0;\n                                          s1 = peg$c300();\n                                        }\n                                        s0 = s1;\n                                        if (s0 === peg$FAILED) {\n                                          s0 = peg$currPos;\n                                          if (input.substr(peg$currPos, 2) === peg$c301) {\n                                            s1 = peg$c301;\n                                            peg$currPos += 2;\n                                          } else {\n                                            s1 = peg$FAILED;\n                                            if (peg$silentFails === 0) { peg$fail(peg$c302); }\n                                          }\n                                          if (s1 !== peg$FAILED) {\n                                            peg$savedPos = s0;\n                                            s1 = peg$c303();\n                                          }\n                                          s0 = s1;\n                                          if (s0 === peg$FAILED) {\n                                            s0 = peg$currPos;\n                                            if (input.charCodeAt(peg$currPos) === 10752) {\n                                              s1 = peg$c304;\n                                              peg$currPos++;\n                                            } else {\n                                              s1 = peg$FAILED;\n                                              if (peg$silentFails === 0) { peg$fail(peg$c305); }\n                                            }\n                                            if (s1 !== peg$FAILED) {\n                                              peg$savedPos = s0;\n                                              s1 = peg$c306();\n                                            }\n                                            s0 = s1;\n                                            if (s0 === peg$FAILED) {\n                                              s0 = peg$currPos;\n                                              if (input.charCodeAt(peg$currPos) === 10227) {\n                                                s1 = peg$c307;\n                                                peg$currPos++;\n                                              } else {\n                                                s1 = peg$FAILED;\n                                                if (peg$silentFails === 0) { peg$fail(peg$c308); }\n                                              }\n                                              if (s1 !== peg$FAILED) {\n                                                peg$savedPos = s0;\n                                                s1 = peg$c309();\n                                              }\n                                              s0 = s1;\n                                              if (s0 === peg$FAILED) {\n                                                s0 = peg$currPos;\n                                                if (input.charCodeAt(peg$currPos) === 8594) {\n                                                  s1 = peg$c310;\n                                                  peg$currPos++;\n                                                } else {\n                                                  s1 = peg$FAILED;\n                                                  if (peg$silentFails === 0) { peg$fail(peg$c311); }\n                                                }\n                                                if (s1 !== peg$FAILED) {\n                                                  peg$savedPos = s0;\n                                                  s1 = peg$c312();\n                                                }\n                                                s0 = s1;\n                                                if (s0 === peg$FAILED) {\n                                                  s0 = peg$currPos;\n                                                  if (input.charCodeAt(peg$currPos) === 8593) {\n                                                    s1 = peg$c313;\n                                                    peg$currPos++;\n                                                  } else {\n                                                    s1 = peg$FAILED;\n                                                    if (peg$silentFails === 0) { peg$fail(peg$c314); }\n                                                  }\n                                                  if (s1 !== peg$FAILED) {\n                                                    peg$savedPos = s0;\n                                                    s1 = peg$c315();\n                                                  }\n                                                  s0 = s1;\n                                                  if (s0 === peg$FAILED) {\n                                                    s0 = peg$currPos;\n                                                    if (input.charCodeAt(peg$currPos) === 8646) {\n                                                      s1 = peg$c316;\n                                                      peg$currPos++;\n                                                    } else {\n                                                      s1 = peg$FAILED;\n                                                      if (peg$silentFails === 0) { peg$fail(peg$c317); }\n                                                    }\n                                                    if (s1 !== peg$FAILED) {\n                                                      peg$savedPos = s0;\n                                                      s1 = peg$c318();\n                                                    }\n                                                    s0 = s1;\n                                                    if (s0 === peg$FAILED) {\n                                                      s0 = peg$currPos;\n                                                      if (input.charCodeAt(peg$currPos) === 68) {\n                                                        s1 = peg$c319;\n                                                        peg$currPos++;\n                                                      } else {\n                                                        s1 = peg$FAILED;\n                                                        if (peg$silentFails === 0) { peg$fail(peg$c320); }\n                                                      }\n                                                      if (s1 !== peg$FAILED) {\n                                                        peg$savedPos = s0;\n                                                        s1 = peg$c321();\n                                                      }\n                                                      s0 = s1;\n                                                    }\n                                                  }\n                                                }\n                                              }\n                                            }\n                                          }\n                                        }\n                                      }\n                                    }\n                                  }\n                                }\n                              }\n                            }\n                          }\n                        }\n                      }\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n\n    return s0;\n  }\n\n  function peg$parsediscriminator() {\n    var s0;\n\n    s0 = peg$parsecolumn();\n    if (s0 === peg$FAILED) {\n      s0 = peg$parserow();\n    }\n\n    return s0;\n  }\n\n  function peg$parsecheckdisc() {\n    var s0, s1, s2, s3, s4;\n\n    s0 = peg$currPos;\n    s1 = peg$parsediscriminator();\n    if (s1 !== peg$FAILED) {\n      s2 = peg$parsestrike();\n      if (s2 === peg$FAILED) {\n        s2 = null;\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parsecolumn();\n        if (s3 !== peg$FAILED) {\n          s4 = peg$parserow();\n          if (s4 !== peg$FAILED) {\n            s1 = [s1, s2, s3, s4];\n            s0 = s1;\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parsefigure() {\n    var s0;\n\n    if (peg$c322.test(input.charAt(peg$currPos))) {\n      s0 = input.charAt(peg$currPos);\n      peg$currPos++;\n    } else {\n      s0 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c323); }\n    }\n\n    return s0;\n  }\n\n  function peg$parsepromFigure() {\n    var s0;\n\n    if (peg$c324.test(input.charAt(peg$currPos))) {\n      s0 = input.charAt(peg$currPos);\n      peg$currPos++;\n    } else {\n      s0 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c325); }\n    }\n\n    return s0;\n  }\n\n  function peg$parsecolumn() {\n    var s0;\n\n    if (peg$c326.test(input.charAt(peg$currPos))) {\n      s0 = input.charAt(peg$currPos);\n      peg$currPos++;\n    } else {\n      s0 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c327); }\n    }\n\n    return s0;\n  }\n\n  function peg$parserow() {\n    var s0;\n\n    if (peg$c328.test(input.charAt(peg$currPos))) {\n      s0 = input.charAt(peg$currPos);\n      peg$currPos++;\n    } else {\n      s0 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c329); }\n    }\n\n    return s0;\n  }\n\n  function peg$parsestrike() {\n    var s0;\n\n    if (input.charCodeAt(peg$currPos) === 120) {\n      s0 = peg$c330;\n      peg$currPos++;\n    } else {\n      s0 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c331); }\n    }\n\n    return s0;\n  }\n\n  function peg$parsestrikeOrDash() {\n    var s0;\n\n    if (input.charCodeAt(peg$currPos) === 120) {\n      s0 = peg$c330;\n      peg$currPos++;\n    } else {\n      s0 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c331); }\n    }\n    if (s0 === peg$FAILED) {\n      if (input.charCodeAt(peg$currPos) === 45) {\n        s0 = peg$c144;\n        peg$currPos++;\n      } else {\n        s0 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c145); }\n      }\n    }\n\n    return s0;\n  }\n\n\n      function makeInteger(o) {\n          return parseInt(o.join(\"\"), 10);\n      }\n\n\n  peg$result = peg$startRuleFunction();\n\n  if (peg$result !== peg$FAILED && peg$currPos === input.length) {\n    return peg$result;\n  } else {\n    if (peg$result !== peg$FAILED && peg$currPos < input.length) {\n      peg$fail(peg$endExpectation());\n    }\n\n    throw peg$buildStructuredError(\n      peg$maxFailExpected,\n      peg$maxFailPos < input.length ? input.charAt(peg$maxFailPos) : null,\n      peg$maxFailPos < input.length\n        ? peg$computeLocation(peg$maxFailPos, peg$maxFailPos + 1)\n        : peg$computeLocation(peg$maxFailPos, peg$maxFailPos)\n    );\n  }\n}\n\nmodule.exports = {\n  SyntaxError: peg$SyntaxError,\n  parse:       peg$parse\n};\n","/*\n * Copyright (c) 2020, Jeff Hlywa (jhlywa@gmail.com)\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n * 1. Redistributions of source code must retain the above copyright notice,\n *    this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright notice,\n *    this list of conditions and the following disclaimer in the documentation\n *    and/or other materials provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n *\n *----------------------------------------------------------------------------*/\n\n/* minified license below  */\n\n/* @license\n * Copyright (c) 2018, Jeff Hlywa (jhlywa@gmail.com)\n * Released under the BSD license\n * https://github.com/jhlywa/chess.js/blob/master/LICENSE\n */\n\nvar Chess = function(fen) {\n  var BLACK = 'b'\n  var WHITE = 'w'\n\n  var EMPTY = -1\n\n  var PAWN = 'p'\n  var KNIGHT = 'n'\n  var BISHOP = 'b'\n  var ROOK = 'r'\n  var QUEEN = 'q'\n  var KING = 'k'\n\n  var SYMBOLS = 'pnbrqkPNBRQK'\n\n  var DEFAULT_POSITION =\n    'rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1'\n\n  var POSSIBLE_RESULTS = ['1-0', '0-1', '1/2-1/2', '*']\n\n  var PAWN_OFFSETS = {\n    b: [16, 32, 17, 15],\n    w: [-16, -32, -17, -15]\n  }\n\n  var PIECE_OFFSETS = {\n    n: [-18, -33, -31, -14, 18, 33, 31, 14],\n    b: [-17, -15, 17, 15],\n    r: [-16, 1, 16, -1],\n    q: [-17, -16, -15, 1, 17, 16, 15, -1],\n    k: [-17, -16, -15, 1, 17, 16, 15, -1]\n  }\n\n  // prettier-ignore\n  var ATTACKS = [\n    20, 0, 0, 0, 0, 0, 0, 24,  0, 0, 0, 0, 0, 0,20, 0,\n     0,20, 0, 0, 0, 0, 0, 24,  0, 0, 0, 0, 0,20, 0, 0,\n     0, 0,20, 0, 0, 0, 0, 24,  0, 0, 0, 0,20, 0, 0, 0,\n     0, 0, 0,20, 0, 0, 0, 24,  0, 0, 0,20, 0, 0, 0, 0,\n     0, 0, 0, 0,20, 0, 0, 24,  0, 0,20, 0, 0, 0, 0, 0,\n     0, 0, 0, 0, 0,20, 2, 24,  2,20, 0, 0, 0, 0, 0, 0,\n     0, 0, 0, 0, 0, 2,53, 56, 53, 2, 0, 0, 0, 0, 0, 0,\n    24,24,24,24,24,24,56,  0, 56,24,24,24,24,24,24, 0,\n     0, 0, 0, 0, 0, 2,53, 56, 53, 2, 0, 0, 0, 0, 0, 0,\n     0, 0, 0, 0, 0,20, 2, 24,  2,20, 0, 0, 0, 0, 0, 0,\n     0, 0, 0, 0,20, 0, 0, 24,  0, 0,20, 0, 0, 0, 0, 0,\n     0, 0, 0,20, 0, 0, 0, 24,  0, 0, 0,20, 0, 0, 0, 0,\n     0, 0,20, 0, 0, 0, 0, 24,  0, 0, 0, 0,20, 0, 0, 0,\n     0,20, 0, 0, 0, 0, 0, 24,  0, 0, 0, 0, 0,20, 0, 0,\n    20, 0, 0, 0, 0, 0, 0, 24,  0, 0, 0, 0, 0, 0,20\n  ];\n\n  // prettier-ignore\n  var RAYS = [\n     17,  0,  0,  0,  0,  0,  0, 16,  0,  0,  0,  0,  0,  0, 15, 0,\n      0, 17,  0,  0,  0,  0,  0, 16,  0,  0,  0,  0,  0, 15,  0, 0,\n      0,  0, 17,  0,  0,  0,  0, 16,  0,  0,  0,  0, 15,  0,  0, 0,\n      0,  0,  0, 17,  0,  0,  0, 16,  0,  0,  0, 15,  0,  0,  0, 0,\n      0,  0,  0,  0, 17,  0,  0, 16,  0,  0, 15,  0,  0,  0,  0, 0,\n      0,  0,  0,  0,  0, 17,  0, 16,  0, 15,  0,  0,  0,  0,  0, 0,\n      0,  0,  0,  0,  0,  0, 17, 16, 15,  0,  0,  0,  0,  0,  0, 0,\n      1,  1,  1,  1,  1,  1,  1,  0, -1, -1,  -1,-1, -1, -1, -1, 0,\n      0,  0,  0,  0,  0,  0,-15,-16,-17,  0,  0,  0,  0,  0,  0, 0,\n      0,  0,  0,  0,  0,-15,  0,-16,  0,-17,  0,  0,  0,  0,  0, 0,\n      0,  0,  0,  0,-15,  0,  0,-16,  0,  0,-17,  0,  0,  0,  0, 0,\n      0,  0,  0,-15,  0,  0,  0,-16,  0,  0,  0,-17,  0,  0,  0, 0,\n      0,  0,-15,  0,  0,  0,  0,-16,  0,  0,  0,  0,-17,  0,  0, 0,\n      0,-15,  0,  0,  0,  0,  0,-16,  0,  0,  0,  0,  0,-17,  0, 0,\n    -15,  0,  0,  0,  0,  0,  0,-16,  0,  0,  0,  0,  0,  0,-17\n  ];\n\n  var SHIFTS = { p: 0, n: 1, b: 2, r: 3, q: 4, k: 5 }\n\n  var FLAGS = {\n    NORMAL: 'n',\n    CAPTURE: 'c',\n    BIG_PAWN: 'b',\n    EP_CAPTURE: 'e',\n    PROMOTION: 'p',\n    KSIDE_CASTLE: 'k',\n    QSIDE_CASTLE: 'q'\n  }\n\n  var BITS = {\n    NORMAL: 1,\n    CAPTURE: 2,\n    BIG_PAWN: 4,\n    EP_CAPTURE: 8,\n    PROMOTION: 16,\n    KSIDE_CASTLE: 32,\n    QSIDE_CASTLE: 64\n  }\n\n  var RANK_1 = 7\n  var RANK_2 = 6\n  var RANK_3 = 5\n  var RANK_4 = 4\n  var RANK_5 = 3\n  var RANK_6 = 2\n  var RANK_7 = 1\n  var RANK_8 = 0\n\n  // prettier-ignore\n  var SQUARES = {\n    a8:   0, b8:   1, c8:   2, d8:   3, e8:   4, f8:   5, g8:   6, h8:   7,\n    a7:  16, b7:  17, c7:  18, d7:  19, e7:  20, f7:  21, g7:  22, h7:  23,\n    a6:  32, b6:  33, c6:  34, d6:  35, e6:  36, f6:  37, g6:  38, h6:  39,\n    a5:  48, b5:  49, c5:  50, d5:  51, e5:  52, f5:  53, g5:  54, h5:  55,\n    a4:  64, b4:  65, c4:  66, d4:  67, e4:  68, f4:  69, g4:  70, h4:  71,\n    a3:  80, b3:  81, c3:  82, d3:  83, e3:  84, f3:  85, g3:  86, h3:  87,\n    a2:  96, b2:  97, c2:  98, d2:  99, e2: 100, f2: 101, g2: 102, h2: 103,\n    a1: 112, b1: 113, c1: 114, d1: 115, e1: 116, f1: 117, g1: 118, h1: 119\n  };\n\n  var ROOKS = {\n    w: [\n      { square: SQUARES.a1, flag: BITS.QSIDE_CASTLE },\n      { square: SQUARES.h1, flag: BITS.KSIDE_CASTLE }\n    ],\n    b: [\n      { square: SQUARES.a8, flag: BITS.QSIDE_CASTLE },\n      { square: SQUARES.h8, flag: BITS.KSIDE_CASTLE }\n    ]\n  }\n\n  var board = new Array(128)\n  var kings = { w: EMPTY, b: EMPTY }\n  var turn = WHITE\n  var castling = { w: 0, b: 0 }\n  var ep_square = EMPTY\n  var half_moves = 0\n  var move_number = 1\n  var history = []\n  var header = {}\n\n  /* if the user passes in a fen string, load it, else default to\n   * starting position\n   */\n  if (typeof fen === 'undefined') {\n    load(DEFAULT_POSITION)\n  } else {\n    load(fen)\n  }\n\n  function clear(keep_headers) {\n    if (typeof keep_headers === 'undefined') {\n      keep_headers = false\n    }\n\n    board = new Array(128)\n    kings = { w: EMPTY, b: EMPTY }\n    turn = WHITE\n    castling = { w: 0, b: 0 }\n    ep_square = EMPTY\n    half_moves = 0\n    move_number = 1\n    history = []\n    if (!keep_headers) header = {}\n    update_setup(generate_fen())\n  }\n\n  function reset() {\n    load(DEFAULT_POSITION)\n  }\n\n  function load(fen, keep_headers) {\n    if (typeof keep_headers === 'undefined') {\n      keep_headers = false\n    }\n\n    var tokens = fen.split(/\\s+/)\n    var position = tokens[0]\n    var square = 0\n\n    if (!validate_fen(fen).valid) {\n      return false\n    }\n\n    clear(keep_headers)\n\n    for (var i = 0; i < position.length; i++) {\n      var piece = position.charAt(i)\n\n      if (piece === '/') {\n        square += 8\n      } else if (is_digit(piece)) {\n        square += parseInt(piece, 10)\n      } else {\n        var color = piece < 'a' ? WHITE : BLACK\n        put({ type: piece.toLowerCase(), color: color }, algebraic(square))\n        square++\n      }\n    }\n\n    turn = tokens[1]\n\n    if (tokens[2].indexOf('K') > -1) {\n      castling.w |= BITS.KSIDE_CASTLE\n    }\n    if (tokens[2].indexOf('Q') > -1) {\n      castling.w |= BITS.QSIDE_CASTLE\n    }\n    if (tokens[2].indexOf('k') > -1) {\n      castling.b |= BITS.KSIDE_CASTLE\n    }\n    if (tokens[2].indexOf('q') > -1) {\n      castling.b |= BITS.QSIDE_CASTLE\n    }\n\n    ep_square = tokens[3] === '-' ? EMPTY : SQUARES[tokens[3]]\n    half_moves = parseInt(tokens[4], 10)\n    move_number = parseInt(tokens[5], 10)\n\n    update_setup(generate_fen())\n\n    return true\n  }\n\n  /* TODO: this function is pretty much crap - it validates structure but\n   * completely ignores content (e.g. doesn't verify that each side has a king)\n   * ... we should rewrite this, and ditch the silly error_number field while\n   * we're at it\n   */\n  function validate_fen(fen) {\n    var errors = {\n      0: 'No errors.',\n      1: 'FEN string must contain six space-delimited fields.',\n      2: '6th field (move number) must be a positive integer.',\n      3: '5th field (half move counter) must be a non-negative integer.',\n      4: '4th field (en-passant square) is invalid.',\n      5: '3rd field (castling availability) is invalid.',\n      6: '2nd field (side to move) is invalid.',\n      7: \"1st field (piece positions) does not contain 8 '/'-delimited rows.\",\n      8: '1st field (piece positions) is invalid [consecutive numbers].',\n      9: '1st field (piece positions) is invalid [invalid piece].',\n      10: '1st field (piece positions) is invalid [row too large].',\n      11: 'Illegal en-passant square'\n    }\n\n    /* 1st criterion: 6 space-seperated fields? */\n    var tokens = fen.split(/\\s+/)\n    if (tokens.length !== 6) {\n      return { valid: false, error_number: 1, error: errors[1] }\n    }\n\n    /* 2nd criterion: move number field is a integer value > 0? */\n    if (isNaN(tokens[5]) || parseInt(tokens[5], 10) <= 0) {\n      return { valid: false, error_number: 2, error: errors[2] }\n    }\n\n    /* 3rd criterion: half move counter is an integer >= 0? */\n    if (isNaN(tokens[4]) || parseInt(tokens[4], 10) < 0) {\n      return { valid: false, error_number: 3, error: errors[3] }\n    }\n\n    /* 4th criterion: 4th field is a valid e.p.-string? */\n    if (!/^(-|[abcdefgh][36])$/.test(tokens[3])) {\n      return { valid: false, error_number: 4, error: errors[4] }\n    }\n\n    /* 5th criterion: 3th field is a valid castle-string? */\n    if (!/^(KQ?k?q?|Qk?q?|kq?|q|-)$/.test(tokens[2])) {\n      return { valid: false, error_number: 5, error: errors[5] }\n    }\n\n    /* 6th criterion: 2nd field is \"w\" (white) or \"b\" (black)? */\n    if (!/^(w|b)$/.test(tokens[1])) {\n      return { valid: false, error_number: 6, error: errors[6] }\n    }\n\n    /* 7th criterion: 1st field contains 8 rows? */\n    var rows = tokens[0].split('/')\n    if (rows.length !== 8) {\n      return { valid: false, error_number: 7, error: errors[7] }\n    }\n\n    /* 8th criterion: every row is valid? */\n    for (var i = 0; i < rows.length; i++) {\n      /* check for right sum of fields AND not two numbers in succession */\n      var sum_fields = 0\n      var previous_was_number = false\n\n      for (var k = 0; k < rows[i].length; k++) {\n        if (!isNaN(rows[i][k])) {\n          if (previous_was_number) {\n            return { valid: false, error_number: 8, error: errors[8] }\n          }\n          sum_fields += parseInt(rows[i][k], 10)\n          previous_was_number = true\n        } else {\n          if (!/^[prnbqkPRNBQK]$/.test(rows[i][k])) {\n            return { valid: false, error_number: 9, error: errors[9] }\n          }\n          sum_fields += 1\n          previous_was_number = false\n        }\n      }\n      if (sum_fields !== 8) {\n        return { valid: false, error_number: 10, error: errors[10] }\n      }\n    }\n\n    if (\n      (tokens[3][1] == '3' && tokens[1] == 'w') ||\n      (tokens[3][1] == '6' && tokens[1] == 'b')\n    ) {\n      return { valid: false, error_number: 11, error: errors[11] }\n    }\n\n    /* everything's okay! */\n    return { valid: true, error_number: 0, error: errors[0] }\n  }\n\n  function generate_fen() {\n    var empty = 0\n    var fen = ''\n\n    for (var i = SQUARES.a8; i <= SQUARES.h1; i++) {\n      if (board[i] == null) {\n        empty++\n      } else {\n        if (empty > 0) {\n          fen += empty\n          empty = 0\n        }\n        var color = board[i].color\n        var piece = board[i].type\n\n        fen += color === WHITE ? piece.toUpperCase() : piece.toLowerCase()\n      }\n\n      if ((i + 1) & 0x88) {\n        if (empty > 0) {\n          fen += empty\n        }\n\n        if (i !== SQUARES.h1) {\n          fen += '/'\n        }\n\n        empty = 0\n        i += 8\n      }\n    }\n\n    var cflags = ''\n    if (castling[WHITE] & BITS.KSIDE_CASTLE) {\n      cflags += 'K'\n    }\n    if (castling[WHITE] & BITS.QSIDE_CASTLE) {\n      cflags += 'Q'\n    }\n    if (castling[BLACK] & BITS.KSIDE_CASTLE) {\n      cflags += 'k'\n    }\n    if (castling[BLACK] & BITS.QSIDE_CASTLE) {\n      cflags += 'q'\n    }\n\n    /* do we have an empty castling flag? */\n    cflags = cflags || '-'\n    var epflags = ep_square === EMPTY ? '-' : algebraic(ep_square)\n\n    return [fen, turn, cflags, epflags, half_moves, move_number].join(' ')\n  }\n\n  function set_header(args) {\n    for (var i = 0; i < args.length; i += 2) {\n      if (typeof args[i] === 'string' && typeof args[i + 1] === 'string') {\n        header[args[i]] = args[i + 1]\n      }\n    }\n    return header\n  }\n\n  /* called when the initial board setup is changed with put() or remove().\n   * modifies the SetUp and FEN properties of the header object.  if the FEN is\n   * equal to the default position, the SetUp and FEN are deleted\n   * the setup is only updated if history.length is zero, ie moves haven't been\n   * made.\n   */\n  function update_setup(fen) {\n    if (history.length > 0) return\n\n    if (fen !== DEFAULT_POSITION) {\n      header['SetUp'] = '1'\n      header['FEN'] = fen\n    } else {\n      delete header['SetUp']\n      delete header['FEN']\n    }\n  }\n\n  function get(square) {\n    var piece = board[SQUARES[square]]\n    return piece ? { type: piece.type, color: piece.color } : null\n  }\n\n  function put(piece, square) {\n    /* check for valid piece object */\n    if (!('type' in piece && 'color' in piece)) {\n      return false\n    }\n\n    /* check for piece */\n    if (SYMBOLS.indexOf(piece.type.toLowerCase()) === -1) {\n      return false\n    }\n\n    /* check for valid square */\n    if (!(square in SQUARES)) {\n      return false\n    }\n\n    var sq = SQUARES[square]\n\n    /* don't let the user place more than one king */\n    if (\n      piece.type == KING &&\n      !(kings[piece.color] == EMPTY || kings[piece.color] == sq)\n    ) {\n      return false\n    }\n\n    board[sq] = { type: piece.type, color: piece.color }\n    if (piece.type === KING) {\n      kings[piece.color] = sq\n    }\n\n    update_setup(generate_fen())\n\n    return true\n  }\n\n  function remove(square) {\n    var piece = get(square)\n    board[SQUARES[square]] = null\n    if (piece && piece.type === KING) {\n      kings[piece.color] = EMPTY\n    }\n\n    update_setup(generate_fen())\n\n    return piece\n  }\n\n  function build_move(board, from, to, flags, promotion) {\n    var move = {\n      color: turn,\n      from: from,\n      to: to,\n      flags: flags,\n      piece: board[from].type\n    }\n\n    if (promotion) {\n      move.flags |= BITS.PROMOTION\n      move.promotion = promotion\n    }\n\n    if (board[to]) {\n      move.captured = board[to].type\n    } else if (flags & BITS.EP_CAPTURE) {\n      move.captured = PAWN\n    }\n    return move\n  }\n\n  function generate_moves(options) {\n    function add_move(board, moves, from, to, flags) {\n      /* if pawn promotion */\n      if (\n        board[from].type === PAWN &&\n        (rank(to) === RANK_8 || rank(to) === RANK_1)\n      ) {\n        var pieces = [QUEEN, ROOK, BISHOP, KNIGHT]\n        for (var i = 0, len = pieces.length; i < len; i++) {\n          moves.push(build_move(board, from, to, flags, pieces[i]))\n        }\n      } else {\n        moves.push(build_move(board, from, to, flags))\n      }\n    }\n\n    var moves = []\n    var us = turn\n    var them = swap_color(us)\n    var second_rank = { b: RANK_7, w: RANK_2 }\n\n    var first_sq = SQUARES.a8\n    var last_sq = SQUARES.h1\n    var single_square = false\n\n    /* do we want legal moves? */\n    var legal =\n      typeof options !== 'undefined' && 'legal' in options\n        ? options.legal\n        : true\n\n    /* are we generating moves for a single square? */\n    if (typeof options !== 'undefined' && 'square' in options) {\n      if (options.square in SQUARES) {\n        first_sq = last_sq = SQUARES[options.square]\n        single_square = true\n      } else {\n        /* invalid square */\n        return []\n      }\n    }\n\n    for (var i = first_sq; i <= last_sq; i++) {\n      /* did we run off the end of the board */\n      if (i & 0x88) {\n        i += 7\n        continue\n      }\n\n      var piece = board[i]\n      if (piece == null || piece.color !== us) {\n        continue\n      }\n\n      if (piece.type === PAWN) {\n        /* single square, non-capturing */\n        var square = i + PAWN_OFFSETS[us][0]\n        if (board[square] == null) {\n          add_move(board, moves, i, square, BITS.NORMAL)\n\n          /* double square */\n          var square = i + PAWN_OFFSETS[us][1]\n          if (second_rank[us] === rank(i) && board[square] == null) {\n            add_move(board, moves, i, square, BITS.BIG_PAWN)\n          }\n        }\n\n        /* pawn captures */\n        for (j = 2; j < 4; j++) {\n          var square = i + PAWN_OFFSETS[us][j]\n          if (square & 0x88) continue\n\n          if (board[square] != null && board[square].color === them) {\n            add_move(board, moves, i, square, BITS.CAPTURE)\n          } else if (square === ep_square) {\n            add_move(board, moves, i, ep_square, BITS.EP_CAPTURE)\n          }\n        }\n      } else {\n        for (var j = 0, len = PIECE_OFFSETS[piece.type].length; j < len; j++) {\n          var offset = PIECE_OFFSETS[piece.type][j]\n          var square = i\n\n          while (true) {\n            square += offset\n            if (square & 0x88) break\n\n            if (board[square] == null) {\n              add_move(board, moves, i, square, BITS.NORMAL)\n            } else {\n              if (board[square].color === us) break\n              add_move(board, moves, i, square, BITS.CAPTURE)\n              break\n            }\n\n            /* break, if knight or king */\n            if (piece.type === 'n' || piece.type === 'k') break\n          }\n        }\n      }\n    }\n\n    /* check for castling if: a) we're generating all moves, or b) we're doing\n     * single square move generation on the king's square\n     */\n    if (!single_square || last_sq === kings[us]) {\n      /* king-side castling */\n      if (castling[us] & BITS.KSIDE_CASTLE) {\n        var castling_from = kings[us]\n        var castling_to = castling_from + 2\n\n        if (\n          board[castling_from + 1] == null &&\n          board[castling_to] == null &&\n          !attacked(them, kings[us]) &&\n          !attacked(them, castling_from + 1) &&\n          !attacked(them, castling_to)\n        ) {\n          add_move(board, moves, kings[us], castling_to, BITS.KSIDE_CASTLE)\n        }\n      }\n\n      /* queen-side castling */\n      if (castling[us] & BITS.QSIDE_CASTLE) {\n        var castling_from = kings[us]\n        var castling_to = castling_from - 2\n\n        if (\n          board[castling_from - 1] == null &&\n          board[castling_from - 2] == null &&\n          board[castling_from - 3] == null &&\n          !attacked(them, kings[us]) &&\n          !attacked(them, castling_from - 1) &&\n          !attacked(them, castling_to)\n        ) {\n          add_move(board, moves, kings[us], castling_to, BITS.QSIDE_CASTLE)\n        }\n      }\n    }\n\n    /* return all pseudo-legal moves (this includes moves that allow the king\n     * to be captured)\n     */\n    if (!legal) {\n      return moves\n    }\n\n    /* filter out illegal moves */\n    var legal_moves = []\n    for (var i = 0, len = moves.length; i < len; i++) {\n      make_move(moves[i])\n      if (!king_attacked(us)) {\n        legal_moves.push(moves[i])\n      }\n      undo_move()\n    }\n\n    return legal_moves\n  }\n\n  /* convert a move from 0x88 coordinates to Standard Algebraic Notation\n   * (SAN)\n   *\n   * @param {boolean} sloppy Use the sloppy SAN generator to work around over\n   * disambiguation bugs in Fritz and Chessbase.  See below:\n   *\n   * r1bqkbnr/ppp2ppp/2n5/1B1pP3/4P3/8/PPPP2PP/RNBQK1NR b KQkq - 2 4\n   * 4. ... Nge7 is overly disambiguated because the knight on c6 is pinned\n   * 4. ... Ne7 is technically the valid SAN\n   */\n  function move_to_san(move, sloppy) {\n    var output = ''\n\n    if (move.flags & BITS.KSIDE_CASTLE) {\n      output = 'O-O'\n    } else if (move.flags & BITS.QSIDE_CASTLE) {\n      output = 'O-O-O'\n    } else {\n      var disambiguator = get_disambiguator(move, sloppy)\n\n      if (move.piece !== PAWN) {\n        output += move.piece.toUpperCase() + disambiguator\n      }\n\n      if (move.flags & (BITS.CAPTURE | BITS.EP_CAPTURE)) {\n        if (move.piece === PAWN) {\n          output += algebraic(move.from)[0]\n        }\n        output += 'x'\n      }\n\n      output += algebraic(move.to)\n\n      if (move.flags & BITS.PROMOTION) {\n        output += '=' + move.promotion.toUpperCase()\n      }\n    }\n\n    make_move(move)\n    if (in_check()) {\n      if (in_checkmate()) {\n        output += '#'\n      } else {\n        output += '+'\n      }\n    }\n    undo_move()\n\n    return output\n  }\n\n  // parses all of the decorators out of a SAN string\n  function stripped_san(move) {\n    return move.replace(/=/, '').replace(/[+#]?[?!]*$/, '')\n  }\n\n  function attacked(color, square) {\n    for (var i = SQUARES.a8; i <= SQUARES.h1; i++) {\n      /* did we run off the end of the board */\n      if (i & 0x88) {\n        i += 7\n        continue\n      }\n\n      /* if empty square or wrong color */\n      if (board[i] == null || board[i].color !== color) continue\n\n      var piece = board[i]\n      var difference = i - square\n      var index = difference + 119\n\n      if (ATTACKS[index] & (1 << SHIFTS[piece.type])) {\n        if (piece.type === PAWN) {\n          if (difference > 0) {\n            if (piece.color === WHITE) return true\n          } else {\n            if (piece.color === BLACK) return true\n          }\n          continue\n        }\n\n        /* if the piece is a knight or a king */\n        if (piece.type === 'n' || piece.type === 'k') return true\n\n        var offset = RAYS[index]\n        var j = i + offset\n\n        var blocked = false\n        while (j !== square) {\n          if (board[j] != null) {\n            blocked = true\n            break\n          }\n          j += offset\n        }\n\n        if (!blocked) return true\n      }\n    }\n\n    return false\n  }\n\n  function king_attacked(color) {\n    return attacked(swap_color(color), kings[color])\n  }\n\n  function in_check() {\n    return king_attacked(turn)\n  }\n\n  function in_checkmate() {\n    return in_check() && generate_moves().length === 0\n  }\n\n  function in_stalemate() {\n    return !in_check() && generate_moves().length === 0\n  }\n\n  function insufficient_material() {\n    var pieces = {}\n    var bishops = []\n    var num_pieces = 0\n    var sq_color = 0\n\n    for (var i = SQUARES.a8; i <= SQUARES.h1; i++) {\n      sq_color = (sq_color + 1) % 2\n      if (i & 0x88) {\n        i += 7\n        continue\n      }\n\n      var piece = board[i]\n      if (piece) {\n        pieces[piece.type] = piece.type in pieces ? pieces[piece.type] + 1 : 1\n        if (piece.type === BISHOP) {\n          bishops.push(sq_color)\n        }\n        num_pieces++\n      }\n    }\n\n    /* k vs. k */\n    if (num_pieces === 2) {\n      return true\n    } else if (\n      /* k vs. kn .... or .... k vs. kb */\n      num_pieces === 3 &&\n      (pieces[BISHOP] === 1 || pieces[KNIGHT] === 1)\n    ) {\n      return true\n    } else if (num_pieces === pieces[BISHOP] + 2) {\n      /* kb vs. kb where any number of bishops are all on the same color */\n      var sum = 0\n      var len = bishops.length\n      for (var i = 0; i < len; i++) {\n        sum += bishops[i]\n      }\n      if (sum === 0 || sum === len) {\n        return true\n      }\n    }\n\n    return false\n  }\n\n  function in_threefold_repetition() {\n    /* TODO: while this function is fine for casual use, a better\n     * implementation would use a Zobrist key (instead of FEN). the\n     * Zobrist key would be maintained in the make_move/undo_move functions,\n     * avoiding the costly that we do below.\n     */\n    var moves = []\n    var positions = {}\n    var repetition = false\n\n    while (true) {\n      var move = undo_move()\n      if (!move) break\n      moves.push(move)\n    }\n\n    while (true) {\n      /* remove the last two fields in the FEN string, they're not needed\n       * when checking for draw by rep */\n      var fen = generate_fen()\n        .split(' ')\n        .slice(0, 4)\n        .join(' ')\n\n      /* has the position occurred three or move times */\n      positions[fen] = fen in positions ? positions[fen] + 1 : 1\n      if (positions[fen] >= 3) {\n        repetition = true\n      }\n\n      if (!moves.length) {\n        break\n      }\n      make_move(moves.pop())\n    }\n\n    return repetition\n  }\n\n  function push(move) {\n    history.push({\n      move: move,\n      kings: { b: kings.b, w: kings.w },\n      turn: turn,\n      castling: { b: castling.b, w: castling.w },\n      ep_square: ep_square,\n      half_moves: half_moves,\n      move_number: move_number\n    })\n  }\n\n  function make_move(move) {\n    var us = turn\n    var them = swap_color(us)\n    push(move)\n\n    board[move.to] = board[move.from]\n    board[move.from] = null\n\n    /* if ep capture, remove the captured pawn */\n    if (move.flags & BITS.EP_CAPTURE) {\n      if (turn === BLACK) {\n        board[move.to - 16] = null\n      } else {\n        board[move.to + 16] = null\n      }\n    }\n\n    /* if pawn promotion, replace with new piece */\n    if (move.flags & BITS.PROMOTION) {\n      board[move.to] = { type: move.promotion, color: us }\n    }\n\n    /* if we moved the king */\n    if (board[move.to].type === KING) {\n      kings[board[move.to].color] = move.to\n\n      /* if we castled, move the rook next to the king */\n      if (move.flags & BITS.KSIDE_CASTLE) {\n        var castling_to = move.to - 1\n        var castling_from = move.to + 1\n        board[castling_to] = board[castling_from]\n        board[castling_from] = null\n      } else if (move.flags & BITS.QSIDE_CASTLE) {\n        var castling_to = move.to + 1\n        var castling_from = move.to - 2\n        board[castling_to] = board[castling_from]\n        board[castling_from] = null\n      }\n\n      /* turn off castling */\n      castling[us] = ''\n    }\n\n    /* turn off castling if we move a rook */\n    if (castling[us]) {\n      for (var i = 0, len = ROOKS[us].length; i < len; i++) {\n        if (\n          move.from === ROOKS[us][i].square &&\n          castling[us] & ROOKS[us][i].flag\n        ) {\n          castling[us] ^= ROOKS[us][i].flag\n          break\n        }\n      }\n    }\n\n    /* turn off castling if we capture a rook */\n    if (castling[them]) {\n      for (var i = 0, len = ROOKS[them].length; i < len; i++) {\n        if (\n          move.to === ROOKS[them][i].square &&\n          castling[them] & ROOKS[them][i].flag\n        ) {\n          castling[them] ^= ROOKS[them][i].flag\n          break\n        }\n      }\n    }\n\n    /* if big pawn move, update the en passant square */\n    if (move.flags & BITS.BIG_PAWN) {\n      if (turn === 'b') {\n        ep_square = move.to - 16\n      } else {\n        ep_square = move.to + 16\n      }\n    } else {\n      ep_square = EMPTY\n    }\n\n    /* reset the 50 move counter if a pawn is moved or a piece is captured */\n    if (move.piece === PAWN) {\n      half_moves = 0\n    } else if (move.flags & (BITS.CAPTURE | BITS.EP_CAPTURE)) {\n      half_moves = 0\n    } else {\n      half_moves++\n    }\n\n    if (turn === BLACK) {\n      move_number++\n    }\n    turn = swap_color(turn)\n  }\n\n  function undo_move() {\n    var old = history.pop()\n    if (old == null) {\n      return null\n    }\n\n    var move = old.move\n    kings = old.kings\n    turn = old.turn\n    castling = old.castling\n    ep_square = old.ep_square\n    half_moves = old.half_moves\n    move_number = old.move_number\n\n    var us = turn\n    var them = swap_color(turn)\n\n    board[move.from] = board[move.to]\n    board[move.from].type = move.piece // to undo any promotions\n    board[move.to] = null\n\n    if (move.flags & BITS.CAPTURE) {\n      board[move.to] = { type: move.captured, color: them }\n    } else if (move.flags & BITS.EP_CAPTURE) {\n      var index\n      if (us === BLACK) {\n        index = move.to - 16\n      } else {\n        index = move.to + 16\n      }\n      board[index] = { type: PAWN, color: them }\n    }\n\n    if (move.flags & (BITS.KSIDE_CASTLE | BITS.QSIDE_CASTLE)) {\n      var castling_to, castling_from\n      if (move.flags & BITS.KSIDE_CASTLE) {\n        castling_to = move.to + 1\n        castling_from = move.to - 1\n      } else if (move.flags & BITS.QSIDE_CASTLE) {\n        castling_to = move.to - 2\n        castling_from = move.to + 1\n      }\n\n      board[castling_to] = board[castling_from]\n      board[castling_from] = null\n    }\n\n    return move\n  }\n\n  /* this function is used to uniquely identify ambiguous moves */\n  function get_disambiguator(move, sloppy) {\n    var moves = generate_moves({ legal: !sloppy })\n\n    var from = move.from\n    var to = move.to\n    var piece = move.piece\n\n    var ambiguities = 0\n    var same_rank = 0\n    var same_file = 0\n\n    for (var i = 0, len = moves.length; i < len; i++) {\n      var ambig_from = moves[i].from\n      var ambig_to = moves[i].to\n      var ambig_piece = moves[i].piece\n\n      /* if a move of the same piece type ends on the same to square, we'll\n       * need to add a disambiguator to the algebraic notation\n       */\n      if (piece === ambig_piece && from !== ambig_from && to === ambig_to) {\n        ambiguities++\n\n        if (rank(from) === rank(ambig_from)) {\n          same_rank++\n        }\n\n        if (file(from) === file(ambig_from)) {\n          same_file++\n        }\n      }\n    }\n\n    if (ambiguities > 0) {\n      /* if there exists a similar moving piece on the same rank and file as\n       * the move in question, use the square as the disambiguator\n       */\n      if (same_rank > 0 && same_file > 0) {\n        return algebraic(from)\n      } else if (same_file > 0) {\n        /* if the moving piece rests on the same file, use the rank symbol as the\n         * disambiguator\n         */\n        return algebraic(from).charAt(1)\n      } else {\n        /* else use the file symbol */\n        return algebraic(from).charAt(0)\n      }\n    }\n\n    return ''\n  }\n\n  function ascii() {\n    var s = '   +------------------------+\\n'\n    for (var i = SQUARES.a8; i <= SQUARES.h1; i++) {\n      /* display the rank */\n      if (file(i) === 0) {\n        s += ' ' + '87654321'[rank(i)] + ' |'\n      }\n\n      /* empty piece */\n      if (board[i] == null) {\n        s += ' . '\n      } else {\n        var piece = board[i].type\n        var color = board[i].color\n        var symbol = color === WHITE ? piece.toUpperCase() : piece.toLowerCase()\n        s += ' ' + symbol + ' '\n      }\n\n      if ((i + 1) & 0x88) {\n        s += '|\\n'\n        i += 8\n      }\n    }\n    s += '   +------------------------+\\n'\n    s += '     a  b  c  d  e  f  g  h\\n'\n\n    return s\n  }\n\n  // convert a move from Standard Algebraic Notation (SAN) to 0x88 coordinates\n  function move_from_san(move, sloppy) {\n    // strip off any move decorations: e.g Nf3+?!\n    var clean_move = stripped_san(move)\n\n    // if we're using the sloppy parser run a regex to grab piece, to, and from\n    // this should parse invalid SAN like: Pe2-e4, Rc1c4, Qf3xf7\n    if (sloppy) {\n      var matches = clean_move.match(\n        /([pnbrqkPNBRQK])?([a-h][1-8])x?-?([a-h][1-8])([qrbnQRBN])?/\n      )\n      if (matches) {\n        var piece = matches[1]\n        var from = matches[2]\n        var to = matches[3]\n        var promotion = matches[4]\n      }\n    }\n\n    var moves = generate_moves()\n    for (var i = 0, len = moves.length; i < len; i++) {\n      // try the strict parser first, then the sloppy parser if requested\n      // by the user\n      if (\n        clean_move === stripped_san(move_to_san(moves[i])) ||\n        (sloppy && clean_move === stripped_san(move_to_san(moves[i], true)))\n      ) {\n        return moves[i]\n      } else {\n        if (\n          matches &&\n          (!piece || piece.toLowerCase() == moves[i].piece) &&\n          SQUARES[from] == moves[i].from &&\n          SQUARES[to] == moves[i].to &&\n          (!promotion || promotion.toLowerCase() == moves[i].promotion)\n        ) {\n          return moves[i]\n        }\n      }\n    }\n\n    return null\n  }\n\n  /*****************************************************************************\n   * UTILITY FUNCTIONS\n   ****************************************************************************/\n  function rank(i) {\n    return i >> 4\n  }\n\n  function file(i) {\n    return i & 15\n  }\n\n  function algebraic(i) {\n    var f = file(i),\n      r = rank(i)\n    return 'abcdefgh'.substring(f, f + 1) + '87654321'.substring(r, r + 1)\n  }\n\n  function swap_color(c) {\n    return c === WHITE ? BLACK : WHITE\n  }\n\n  function is_digit(c) {\n    return '0123456789'.indexOf(c) !== -1\n  }\n\n  /* pretty = external move object */\n  function make_pretty(ugly_move) {\n    var move = clone(ugly_move)\n    move.san = move_to_san(move, false)\n    move.to = algebraic(move.to)\n    move.from = algebraic(move.from)\n\n    var flags = ''\n\n    for (var flag in BITS) {\n      if (BITS[flag] & move.flags) {\n        flags += FLAGS[flag]\n      }\n    }\n    move.flags = flags\n\n    return move\n  }\n\n  function clone(obj) {\n    var dupe = obj instanceof Array ? [] : {}\n\n    for (var property in obj) {\n      if (typeof property === 'object') {\n        dupe[property] = clone(obj[property])\n      } else {\n        dupe[property] = obj[property]\n      }\n    }\n\n    return dupe\n  }\n\n  function trim(str) {\n    return str.replace(/^\\s+|\\s+$/g, '')\n  }\n\n  /*****************************************************************************\n   * DEBUGGING UTILITIES\n   ****************************************************************************/\n  function perft(depth) {\n    var moves = generate_moves({ legal: false })\n    var nodes = 0\n    var color = turn\n\n    for (var i = 0, len = moves.length; i < len; i++) {\n      make_move(moves[i])\n      if (!king_attacked(color)) {\n        if (depth - 1 > 0) {\n          var child_nodes = perft(depth - 1)\n          nodes += child_nodes\n        } else {\n          nodes++\n        }\n      }\n      undo_move()\n    }\n\n    return nodes\n  }\n\n  return {\n    /***************************************************************************\n     * PUBLIC CONSTANTS (is there a better way to do this?)\n     **************************************************************************/\n    WHITE: WHITE,\n    BLACK: BLACK,\n    PAWN: PAWN,\n    KNIGHT: KNIGHT,\n    BISHOP: BISHOP,\n    ROOK: ROOK,\n    QUEEN: QUEEN,\n    KING: KING,\n    SQUARES: (function() {\n      /* from the ECMA-262 spec (section 12.6.4):\n       * \"The mechanics of enumerating the properties ... is\n       * implementation dependent\"\n       * so: for (var sq in SQUARES) { keys.push(sq); } might not be\n       * ordered correctly\n       */\n      var keys = []\n      for (var i = SQUARES.a8; i <= SQUARES.h1; i++) {\n        if (i & 0x88) {\n          i += 7\n          continue\n        }\n        keys.push(algebraic(i))\n      }\n      return keys\n    })(),\n    FLAGS: FLAGS,\n\n    /***************************************************************************\n     * PUBLIC API\n     **************************************************************************/\n    load: function(fen) {\n      return load(fen)\n    },\n\n    reset: function() {\n      return reset()\n    },\n\n    moves: function(options) {\n      /* The internal representation of a chess move is in 0x88 format, and\n       * not meant to be human-readable.  The code below converts the 0x88\n       * square coordinates to algebraic coordinates.  It also prunes an\n       * unnecessary move keys resulting from a verbose call.\n       */\n\n      var ugly_moves = generate_moves(options)\n      var moves = []\n\n      for (var i = 0, len = ugly_moves.length; i < len; i++) {\n        /* does the user want a full move object (most likely not), or just\n         * SAN\n         */\n        if (\n          typeof options !== 'undefined' &&\n          'verbose' in options &&\n          options.verbose\n        ) {\n          moves.push(make_pretty(ugly_moves[i]))\n        } else {\n          moves.push(move_to_san(ugly_moves[i], false))\n        }\n      }\n\n      return moves\n    },\n\n    in_check: function() {\n      return in_check()\n    },\n\n    in_checkmate: function() {\n      return in_checkmate()\n    },\n\n    in_stalemate: function() {\n      return in_stalemate()\n    },\n\n    in_draw: function() {\n      return (\n        half_moves >= 100 ||\n        in_stalemate() ||\n        insufficient_material() ||\n        in_threefold_repetition()\n      )\n    },\n\n    insufficient_material: function() {\n      return insufficient_material()\n    },\n\n    in_threefold_repetition: function() {\n      return in_threefold_repetition()\n    },\n\n    game_over: function() {\n      return (\n        half_moves >= 100 ||\n        in_checkmate() ||\n        in_stalemate() ||\n        insufficient_material() ||\n        in_threefold_repetition()\n      )\n    },\n\n    validate_fen: function(fen) {\n      return validate_fen(fen)\n    },\n\n    fen: function() {\n      return generate_fen()\n    },\n\n    board: function() {\n      var output = [],\n        row = []\n\n      for (var i = SQUARES.a8; i <= SQUARES.h1; i++) {\n        if (board[i] == null) {\n          row.push(null)\n        } else {\n          row.push({ type: board[i].type, color: board[i].color })\n        }\n        if ((i + 1) & 0x88) {\n          output.push(row)\n          row = []\n          i += 8\n        }\n      }\n\n      return output\n    },\n\n    pgn: function(options) {\n      /* using the specification from http://www.chessclub.com/help/PGN-spec\n       * example for html usage: .pgn({ max_width: 72, newline_char: \"<br />\" })\n       */\n      var newline =\n        typeof options === 'object' && typeof options.newline_char === 'string'\n          ? options.newline_char\n          : '\\n'\n      var max_width =\n        typeof options === 'object' && typeof options.max_width === 'number'\n          ? options.max_width\n          : 0\n      var result = []\n      var header_exists = false\n\n      /* add the PGN header headerrmation */\n      for (var i in header) {\n        /* TODO: order of enumerated properties in header object is not\n         * guaranteed, see ECMA-262 spec (section 12.6.4)\n         */\n        result.push('[' + i + ' \"' + header[i] + '\"]' + newline)\n        header_exists = true\n      }\n\n      if (header_exists && history.length) {\n        result.push(newline)\n      }\n\n      /* pop all of history onto reversed_history */\n      var reversed_history = []\n      while (history.length > 0) {\n        reversed_history.push(undo_move())\n      }\n\n      var moves = []\n      var move_string = ''\n\n      /* build the list of moves.  a move_string looks like: \"3. e3 e6\" */\n      while (reversed_history.length > 0) {\n        var move = reversed_history.pop()\n\n        /* if the position started with black to move, start PGN with 1. ... */\n        if (!history.length && move.color === 'b') {\n          move_string = move_number + '. ...'\n        } else if (move.color === 'w') {\n          /* store the previous generated move_string if we have one */\n          if (move_string.length) {\n            moves.push(move_string)\n          }\n          move_string = move_number + '.'\n        }\n\n        move_string = move_string + ' ' + move_to_san(move, false)\n        make_move(move)\n      }\n\n      /* are there any other leftover moves? */\n      if (move_string.length) {\n        moves.push(move_string)\n      }\n\n      /* is there a result? */\n      if (typeof header.Result !== 'undefined') {\n        moves.push(header.Result)\n      }\n\n      /* history should be back to what is was before we started generating PGN,\n       * so join together moves\n       */\n      if (max_width === 0) {\n        return result.join('') + moves.join(' ')\n      }\n\n      /* wrap the PGN output at max_width */\n      var current_width = 0\n      for (var i = 0; i < moves.length; i++) {\n        /* if the current move will push past max_width */\n        if (current_width + moves[i].length > max_width && i !== 0) {\n          /* don't end the line with whitespace */\n          if (result[result.length - 1] === ' ') {\n            result.pop()\n          }\n\n          result.push(newline)\n          current_width = 0\n        } else if (i !== 0) {\n          result.push(' ')\n          current_width++\n        }\n        result.push(moves[i])\n        current_width += moves[i].length\n      }\n\n      return result.join('')\n    },\n\n    load_pgn: function(pgn, options) {\n      // allow the user to specify the sloppy move parser to work around over\n      // disambiguation bugs in Fritz and Chessbase\n      var sloppy =\n        typeof options !== 'undefined' && 'sloppy' in options\n          ? options.sloppy\n          : false\n\n      function mask(str) {\n        return str.replace(/\\\\/g, '\\\\')\n      }\n\n      function has_keys(object) {\n        for (var key in object) {\n          return true\n        }\n        return false\n      }\n\n      function parse_pgn_header(header, options) {\n        var newline_char =\n          typeof options === 'object' &&\n          typeof options.newline_char === 'string'\n            ? options.newline_char\n            : '\\r?\\n'\n        var header_obj = {}\n        var headers = header.split(new RegExp(mask(newline_char)))\n        var key = ''\n        var value = ''\n\n        for (var i = 0; i < headers.length; i++) {\n          key = headers[i].replace(/^\\[([A-Z][A-Za-z]*)\\s.*\\]$/, '$1')\n          value = headers[i].replace(/^\\[[A-Za-z]+\\s\"(.*)\"\\]$/, '$1')\n          if (trim(key).length > 0) {\n            header_obj[key] = value\n          }\n        }\n\n        return header_obj\n      }\n\n      var newline_char =\n        typeof options === 'object' && typeof options.newline_char === 'string'\n          ? options.newline_char\n          : '\\r?\\n'\n\n      // RegExp to split header. Takes advantage of the fact that header and movetext\n      // will always have a blank line between them (ie, two newline_char's).\n      // With default newline_char, will equal: /^(\\[((?:\\r?\\n)|.)*\\])(?:\\r?\\n){2}/\n      var header_regex = new RegExp(\n        '^(\\\\[((?:' +\n          mask(newline_char) +\n          ')|.)*\\\\])' +\n          '(?:' +\n          mask(newline_char) +\n          '){2}'\n      )\n\n      // If no header given, begin with moves.\n      var header_string = header_regex.test(pgn)\n        ? header_regex.exec(pgn)[1]\n        : ''\n\n      // Put the board in the starting position\n      reset()\n\n      /* parse PGN header */\n      var headers = parse_pgn_header(header_string, options)\n      for (var key in headers) {\n        set_header([key, headers[key]])\n      }\n\n      /* load the starting position indicated by [Setup '1'] and\n       * [FEN position] */\n      if (headers['SetUp'] === '1') {\n        if (!('FEN' in headers && load(headers['FEN'], true))) {\n          // second argument to load: don't clear the headers\n          return false\n        }\n      }\n\n      /* delete header to get the moves */\n      var ms = pgn\n        .replace(header_string, '')\n        .replace(new RegExp(mask(newline_char), 'g'), ' ')\n\n      /* delete comments */\n      ms = ms.replace(/(\\{[^}]+\\})+?/g, '')\n\n      /* delete recursive annotation variations */\n      var rav_regex = /(\\([^\\(\\)]+\\))+?/g\n      while (rav_regex.test(ms)) {\n        ms = ms.replace(rav_regex, '')\n      }\n\n      /* delete move numbers */\n      ms = ms.replace(/\\d+\\.(\\.\\.)?/g, '')\n\n      /* delete ... indicating black to move */\n      ms = ms.replace(/\\.\\.\\./g, '')\n\n      /* delete numeric annotation glyphs */\n      ms = ms.replace(/\\$\\d+/g, '')\n\n      /* trim and get array of moves */\n      var moves = trim(ms).split(new RegExp(/\\s+/))\n\n      /* delete empty entries */\n      moves = moves\n        .join(',')\n        .replace(/,,+/g, ',')\n        .split(',')\n      var move = ''\n\n      for (var half_move = 0; half_move < moves.length - 1; half_move++) {\n        move = move_from_san(moves[half_move], sloppy)\n\n        /* move not possible! (don't clear the board to examine to show the\n         * latest valid position)\n         */\n        if (move == null) {\n          return false\n        } else {\n          make_move(move)\n        }\n      }\n\n      /* examine last move */\n      move = moves[moves.length - 1]\n      if (POSSIBLE_RESULTS.indexOf(move) > -1) {\n        if (has_keys(header) && typeof header.Result === 'undefined') {\n          set_header(['Result', move])\n        }\n      } else {\n        move = move_from_san(move, sloppy)\n        if (move == null) {\n          return false\n        } else {\n          make_move(move)\n        }\n      }\n      return true\n    },\n\n    header: function() {\n      return set_header(arguments)\n    },\n\n    ascii: function() {\n      return ascii()\n    },\n\n    turn: function() {\n      return turn\n    },\n\n    move: function(move, options) {\n      /* The move function can be called with in the following parameters:\n       *\n       * .move('Nxb7')      <- where 'move' is a case-sensitive SAN string\n       *\n       * .move({ from: 'h7', <- where the 'move' is a move object (additional\n       *         to :'h8',      fields are ignored)\n       *         promotion: 'q',\n       *      })\n       */\n\n      // allow the user to specify the sloppy move parser to work around over\n      // disambiguation bugs in Fritz and Chessbase\n      var sloppy =\n        typeof options !== 'undefined' && 'sloppy' in options\n          ? options.sloppy\n          : false\n\n      var move_obj = null\n\n      if (typeof move === 'string') {\n        move_obj = move_from_san(move, sloppy)\n      } else if (typeof move === 'object') {\n        var moves = generate_moves()\n\n        /* convert the pretty move object to an ugly move object */\n        for (var i = 0, len = moves.length; i < len; i++) {\n          if (\n            move.from === algebraic(moves[i].from) &&\n            move.to === algebraic(moves[i].to) &&\n            (!('promotion' in moves[i]) ||\n              move.promotion === moves[i].promotion)\n          ) {\n            move_obj = moves[i]\n            break\n          }\n        }\n      }\n\n      /* failed to find move */\n      if (!move_obj) {\n        return null\n      }\n\n      /* need to make a copy of move because we can't generate SAN after the\n       * move is made\n       */\n      var pretty_move = make_pretty(move_obj)\n\n      make_move(move_obj)\n\n      return pretty_move\n    },\n\n    undo: function() {\n      var move = undo_move()\n      return move ? make_pretty(move) : null\n    },\n\n    clear: function() {\n      return clear()\n    },\n\n    put: function(piece, square) {\n      return put(piece, square)\n    },\n\n    get: function(square) {\n      return get(square)\n    },\n\n    remove: function(square) {\n      return remove(square)\n    },\n\n    perft: function(depth) {\n      return perft(depth)\n    },\n\n    square_color: function(square) {\n      if (square in SQUARES) {\n        var sq_0x88 = SQUARES[square]\n        return (rank(sq_0x88) + file(sq_0x88)) % 2 === 0 ? 'light' : 'dark'\n      }\n\n      return null\n    },\n\n    history: function(options) {\n      var reversed_history = []\n      var move_history = []\n      var verbose =\n        typeof options !== 'undefined' &&\n        'verbose' in options &&\n        options.verbose\n\n      while (history.length > 0) {\n        reversed_history.push(undo_move())\n      }\n\n      while (reversed_history.length > 0) {\n        var move = reversed_history.pop()\n        if (verbose) {\n          move_history.push(make_pretty(move))\n        } else {\n          move_history.push(move_to_san(move))\n        }\n        make_move(move)\n      }\n\n      return move_history\n    }\n  }\n}\n\n/* export Chess object if using node or any other CommonJS compatible\n * environment */\nif (typeof exports !== 'undefined') exports.Chess = Chess\n/* export Chess object for any RequireJS compatible environment */\nif (typeof define !== 'undefined')\n  define(function() {\n    return Chess\n  })\n","import parser from '@mliebelt/pgn-parser';\nimport Chess from 'chess.js';\n\n// Initializes a new instance of the StringBuilder class\n// and appends the given value if supplied\nfunction StringBuilder(value) {\n    let that = {};\n    that.strings = new Array(\"\");\n    // Appends the given value to the end of this instance.\n    let append = function (value) {\n        if (value) {\n            that.strings.push(value);\n        }\n    };\n\n    // Return true if the receiver is empty. Don't compute length!!\n    let isEmpty = function () {\n        for (let i = 0; i < that.strings.length; i++) {\n            if (that.strings[i].length > 0) {\n                return false;\n            }\n        }\n        return true;\n    };\n\n    // Return the last character (as string) of the receiver.\n    // Return null if none is found\n    let lastChar = function () {\n        if (that.strings.length === 0) {\n            return null;\n        }\n        return that.strings[that.strings.length - 1].slice(-1);\n    };\n\n    // Converts this instance to a String.\n    let toString = function () {\n        return that.strings.join(\"\");\n    };\n\n    append(value);\n\n    return {\n        append: append,\n        toString: toString,\n        isEmpty: isEmpty,\n        lastChar: lastChar\n    };\n}\n\nfunction Utils() {\n    let\n        nativeIsArray      = Array.isArray\n\n    let isString = function(obj) {\n        return toString.call(obj) === '[object String]'\n    };\n    let isArguments = function(obj) {\n        return toString.call(obj) === '[object Arguments]'\n    }\n    let MAX_ARRAY_INDEX = Math.pow(2, 53) - 1;  \n    let isArrayLike = function(collection) {\n        const length = getLength(collection);\n        return typeof length == 'number' && length >= 0 && length <= MAX_ARRAY_INDEX;\n    };\n    let isArray = nativeIsArray || function(obj) {\n        return Array.isArray(obj);\n      };\n    let property = function(key) {\n        return function(obj) {\n          return obj == null ? void 0 : obj[key];\n        };\n      };\n    let getLength = property('length');\n    let optimizeCb = function(func, context, argCount) {\n        if (context === void 0) return func;\n        switch (argCount == null ? 3 : argCount) {\n          case 1: return function(value) {\n            return func.call(context, value);\n          };\n          case 2: return function(value, other) {\n            return func.call(context, value, other);\n          };\n          case 3: return function(value, index, collection) {\n            return func.call(context, value, index, collection);\n          };\n          case 4: return function(accumulator, value, index, collection) {\n            return func.call(context, accumulator, value, index, collection);\n          };\n        }\n        return function() {\n          return func.apply(context, arguments);\n        };\n      };\n    // The cornerstone, an `each` implementation, aka `forEach`.\n    // Handles raw objects in addition to array-likes. Treats all\n    // sparse array-likes as if they were dense.\n    let pvEach = function(obj, iteratee, context) {\n        iteratee = optimizeCb(iteratee, context);\n        let i, length;\n        if (isArrayLike(obj)) {\n            for (i = 0, length = obj.length; i < length; i++) {\n                iteratee(obj[i], i, obj);\n            }\n            } else {\n            let keys = Object.keys(obj);\n            for (i = 0, length = keys.length; i < length; i++) {\n                iteratee(obj[keys[i]], keys[i], obj);\n            }\n        }\n        return obj;\n    };\n    // Is a given value a DOM element?\n    let pvIsElement = function(obj) {\n        return !!(obj && obj.nodeType === 1)\n    }\n\n    // Is a given array, string, or object empty?\n    // An \"empty\" object has no enumerable own-properties.\n    let pvIsEmpty = function(obj) {\n        if (obj == null) return true;\n        if (isArrayLike(obj) && (isArray(obj) || isString(obj) || isArguments(obj))) return obj.length === 0;\n        return Object.keys(obj).length === 0;\n    };\n\n    return {\n        pvEach: pvEach,\n        pvIsElement: pvIsElement,\n        pvIsEmpty: pvIsEmpty\n    };\n}\n\n/**\n * Defines the base functionality for reading and working with PGN.\n * The configuration is the part of the configuration given to the PgnViewer that is relevant\n * for the reader.\n * @param {*} configuration Given values that are relevant for reading and working with PGN\n */\nconst pgnReader = function (configuration) {\n    const that = {};\n    let utils = new Utils();\n    const initialize_configuration = function(configuration) {\n        const readPgnFromFile = function(url) {\n            const request = new XMLHttpRequest()\n            request.open('GET', url, false)\n            request.send()\n            if (request.status === 200) {\n                return request.responseText\n            }\n        }\n        let defaults = {\n            notation: 'short',\n            position: 'start',\n            locale: 'en'\n        }\n        if (typeof configuration.pgn == 'undefined') {\n            if (typeof configuration.pgnFile == 'undefined') {\n                configuration.pgn = '';\n            } else {\n                configuration.pgn = readPgnFromFile(configuration.pgnFile);\n            }\n        }\n        return Object.assign(defaults, configuration)\n    };\n    that.configuration = initialize_configuration(configuration);\n    that.startMove = 0;\n    const game = new Chess();\n    const set_to_start = function() {\n        if (that.configuration.position === 'start') {\n                game.reset();\n            } else {\n                game.load(that.configuration.position);\n            }\n    };\n    that.PGN_TAGS = {\n        event: \"the name of the tournament or match event\",\n        site: \"the location of the event\",\n        date: \"the starting date of the game (format: YYYY.MM.TT)\",\n        round: \"the playing round ordinal of the game\",\n        white: \"the player of the white pieces (last name, pre name)\",\n        black: \"the player of the black pieces (last name, pre name)\",\n        result: \"the result of the game (1 - 0, 1/2 - 1/2, 0 - 1)\",\n        // from here, the keys are optional, order may be different\n        board: \"the board number in a team event\",\n        eco: \"ECO-Opening-Key (ECO = 'Encyclopaedia of Chess Openings')\",\n        whitemyelo: \"myELO-score white (at the beginning of the game)\",\n        blackmyelo: \"myELO-score black (at the beginning of the game)\",\n        whitedays: \"rate in days for white\",\n        blackdays: \"rate in days for black\",\n        mychessno: \"identification-no. of the game on the myChess.de - server\",\n        // From here it was from Wikipedia\n        annotator: \"The person providing notes to the game.\",\n        plycount: \"String value denoting total number of half-moves played.\",\n        timecontrol: \"40/7200:3600 (moves per seconds: sudden death seconds)\",\n        time: 'Time the game started, in \"HH:MM:SS\" format, in local clock time.',\n        termination: 'Gives more details about the termination of the game. It may be \"abandoned\", \"adjudication\" (result determined by third-party adjudication), \"death\", \"emergency\", \"normal\", \"rules infraction\", \"time forfeit\", or \"unterminated\".',\n        mode: '\"OTB\" (over-the-board) \"ICS\" (Internet Chess Server)',\n        setup: '\"0\": position is start position, \"1\": tag FEN defines the position',\n        fen: 'Alternative start position, tag SetUp has to be set to \"1\"'\n    };\n    that.PROMOTIONS = {\n        'q': 'queen',\n        'r': 'rook',\n        'b': 'bishop',\n        'n': 'knight'\n    };\n    /**\n     * Returns the NAGs as defined in http://www.saremba.de/chessgml/standards/pgn/pgn-complete.htm#c10\n     * The index is the index number after the '$' sign like in $3 == 'very good move'.\n     * For a complete index, see https://en.wikipedia.org/wiki/Numeric_Annotation_Glyphs\n     * @type {Array} the array with the (english) explanations.\n     */\n    that.NAGs = new Array(220);\n    that.NAGs[1]=    \"!\";    // 1\n    that.NAGs[2]=    \"?\";    // 2\n    that.NAGs[3]=    \"‼\";   // 3\n    that.NAGs[4]=    \"⁇\";   // 4\n    that.NAGs[5]=    \"⁉\";   // 5\n    that.NAGs[6]=    \"⁈\";   // 6\n    that.NAGs[7]=    \"□\";    // 7\n    that.NAGs[10]=    \"=\";    // 10\n    that.NAGs[13]=    \"∞\";    // 13\n    that.NAGs[14]=    \"⩲\";    // 14\n    that.NAGs[15]=    \"⩱\";    // 15\n    that.NAGs[16]=    \"±\";    // 16\n    that.NAGs[17]=    \"∓\";    // 17\n    that.NAGs[18]=    \"+−\";   // 18\n    that.NAGs[19]=    \"-+\";    // 19\n    that.NAGs[22]=    \"⨀\";\n    that.NAGs[23]=    \"⨀\";\n    that.NAGs[32]=    \"⟳\";\n    that.NAGs[33]=    \"⟳\";\n    that.NAGs[36]=    \"→\";\n    that.NAGs[37]=    \"→\";\n    that.NAGs[40]=    \"↑\";\n    that.NAGs[41]=    \"↑\";\n    that.NAGs[44]=    \"=∞\";\n    that.NAGs[132]=   \"⇆\";\n    that.NAGs[133]=   \"⇆\";\n    that.NAGs[136]=   \"⊕\";\n    that.NAGs[140]=   \"∆\";\n    that.NAGs[146]=   \"N\";\n    that.NAGs[220]=   \"D\";\n    that.NAGs[221]=   \"D\";\n\n    that.PGN_NAGS = {};\n\n    // build the reverse index\n    for (let i = 0; i < that.NAGs.length; i++) {\n        that.PGN_NAGS[that.NAGs[i]] = i;\n    }\n    // Special case for duplicate NAGs\n    that.PGN_NAGS['!!'] = 3;\n    that.PGN_NAGS['??'] = 4;\n    that.PGN_NAGS['!?'] = 5;\n    that.PGN_NAGS['?!'] = 6;\n\n    /**\n     * Returns the NAG notation from the array of symbols\n     * @param array the NAG symbols like $1, $3, ...\n     * @returns {string} the result string like !, !!\n     */\n    const nag_to_symbol = function (array) {\n        let ret_string = \"\";\n        if (array === null || array === undefined) {\n            return ret_string;\n        }\n        for (let i = 0; i < array.length; i++) {\n            const number = parseInt(array[i].substring(1));\n            if (number !== 220) { // Don't add diagrams to notation\n                const ret = that.NAGs[number];\n                ret_string += (typeof ret != 'undefined') ? ret : \"$\"+number;\n            }\n        }\n        return ret_string;\n    }\n\n    /**\n     * Returns the internationalized variation of the figure, or the original itself.\n     * Optional pawn symbols are ignored (SAN is used for output, not reading).\n     */\n    const getFig = function (fig) {\n        if (fig === 'P') {\n            return '';\n        }\n        return fig;\n    }\n\n    /**\n     * Returns the real notation from the move (excluding NAGs).\n     * @param move given move in JSON notation\n     * @return {*} the SAN string created from the move\n     */\n    const san = function(move) {\n        let notation = move.notation;\n        if (typeof notation.row === 'undefined') {\n            return notation.notation; // move like O-O and O-O-O\n        }\n        const fig = notation.fig ? getFig(notation.fig) : '';\n        const disc = notation.disc ? notation.disc : '';\n        const strike = notation.strike ? notation.strike : '';\n        // Pawn moves with capture need the col as \"discriminator\"\n        const check = notation.check ? notation.check : '';\n        const mate = notation.mate ? notation.mate : '';\n        const prom = notation.promotion ? '=' + getFig(notation.promotion.substring(1,2)) : '';\n        if (that.configuration.notation === 'short') {\n            return fig + disc + strike + notation.col + notation.row + prom + check + mate;\n        } else if (that.configuration.notation === 'long') {\n            return fig + move.from + (notation.strike ? strike : '-') + move.to + prom + check + mate;\n        }\n    }\n\n    const sanWithNags = function (move) {\n        let _san = san(move);\n        if (move.nag) {\n            _san += nag_to_symbol(move.nag);\n        }\n        return _san;\n    }\n\n    /**\n     * Returns the SYM notation for a single NAG (like !!, ?!, ...)\n     * @param string the NAG in the chess notation\n     * @returns {*} the symbold like $0, $3, ...\n     */\n    const symbol_to_nag = function(string) {\n        const nag = that.PGN_NAGS[string];\n        if (nag === \"undefined\") {\n            return null;\n        } else {\n            return \"$\" + nag;\n        }\n    };\n\n    /**\n     * Main function, automatically called when calling pgn function.\n     * Special handling here, when startPlay and hideMovesBefore are set,\n     * the moves from the beginning to the startPlay are cut. Ugly, but working.\n     */\n    let load_pgn = function () {\n        const interpretHeaders = function () {\n            if (that.tags.SetUp) {\n                const setup = that.tags.SetUp;\n                if (setup === '0') {\n                    that.configuration.position = 'start';\n                } else {\n                    that.configuration.position = that.tags.FEN;\n                }\n            }\n            if (that.tags.Result) {\n                that.endGame = that.tags.Result;            }\n        };\n        let _mgame = parser.parse(that.configuration.pgn, {startRule: \"game\"});\n        that.tags = _mgame.tags;\n        interpretHeaders();\n        readMoves(_mgame.moves);\n        if (that.configuration.startPlay && that.configuration.hideMovesBefore) {\n            let new_fen = deleteMovesBefore(that.configuration.startPlay);\n            let new_pgn = write_pgn();\n            that.configuration.startPlay = null;\n            that.configuration.hideMovesBefore = false;\n            that.configuration.pgn = new_pgn;\n            that.configuration.position = new_fen;\n            load_pgn();\n        }\n        return that;\n    };\n\n    const wireMoves = function(current, prev, currentMove, prevMove) {\n        if (prevMove != null) {\n            currentMove.prev = prev;\n            if (! prevMove.next) { // only set, if not set already\n                prevMove.next = current;\n            }\n        }\n        currentMove.index = current;\n    };\n\n    /**\n     * Read moves read the moves that are not part of the headers.\n     */\n    const readMoves = function(moves) {\n\n        /**\n         * Originally variations are kept as array of moves. But after having linked prev and next,\n         * it is much easier to keep only the first move of the variation.\n         */\n        const correctVariations = function() {\n            utils.pvEach(getMoves(), function(move) {\n                for (let i = 0; i < move.variations.length; i++) {\n                    move.variations[i] = move.variations[i][0];\n                }\n            });\n        };\n        const remindEndGame = function(movesMainLine) {\n            if (typeof movesMainLine[movesMainLine.length - 1] === \"string\") {\n                that.endGame = movesMainLine.pop();\n            }\n        };\n        /**\n         * If black started with a move, FEN must be set to a black start position.\n         * Then turn should be switched for all moves, if first moves is falsly white.\n         */\n        const correctTurn = function() {\n            const getTurn = function(fen) {\n                const tokens = fen.split(/\\s+/);\n                return tokens[1];\n            };\n            //\n            if ((getTurn(that.configuration.position) === 'b') &&\n                    (isMove(0)) &&\n                    (that.moves[0].turn === 'w')) {\n                utils.pvEach(getMoves(), function(move) {\n                    move.turn = (move.turn === 'w') ? 'b' : 'w';\n                });\n            }\n        };\n\n        // Ensure that PGN string is just one line, with no tab or line break in it.\n        const movesMainLine = moves;\n        remindEndGame(movesMainLine);\n        eachMove(movesMainLine);\n        correctTurn();\n        correctVariations();\n    };\n\n    /**\n     * Checks if the move with index id is a valid move\n     * @param id the index of the moves in the moves array\n     * @returns {boolean} true, if there exists a move with that index, false else\n     */\n    const isMove = function(id) {\n        return getMoves().length > id;\n    };\n\n    /**\n     * Returns true, if the move with ID id is deleted.\n     * @param id the numerical index\n     * @returns {boolean} true, if deleted\n     */\n    const isDeleted = function(id) {\n        if (! isMove(id))\n            return true; // Every non-existing moves is \"deleted\"\n        const current = getMoves()[id];\n        if (current === null) {\n            return true;\n        }\n        if (id === 0 && (current)) // The first move is not deleted\n            return false;\n//        return (current.prev === null); // All moves without a previous move are deleted\n    };\n\n\n    /**\n     * Returns the move that matches the id. Take into consideration:\n     * <ul><li>if the move has no pre, and it is not the first one, the move should be considered deleted</li>\n     * <li>if the move has no pre, but it is the first one, it is the first move</li>\n     * </ul>\n     * So only remove a move, if the move is not deleted\n     * @param id the ID of the move\n     */\n    const getMove = function(id) {\n        return getMoves()[id];\n    };\n\n\n    /**\n     * Updates the variation level for all moves. If no arguments are given,\n     * update the variation level for all moves.\n     */\n    const updateVariationLevel = function(move, varLevel) {\n        if (arguments.length === 0) {\n            // Workaround: we don't know which is the first move, so that that with index 0\n            const my_move = getMove(0);\n            updateVariationLevel(my_move, 0);\n        } else {\n            move.variationLevel = varLevel;\n            if (move.next !== undefined) {\n                updateVariationLevel(getMove(move.next), varLevel);\n            }\n            if (move.variations) {\n                for (let i = 0; i < move.variations.length; i++) {\n                    updateVariationLevel(move.variations[i], varLevel + 1);\n                }\n            }\n        }\n    };\n\n    /**\n     * Deletes the move that matches the id (including the move itself).\n     * There are some cases to expect:\n     * <ul><li>the first move of the main line: delete everything</li>\n     * <li>some move in between of the main line: make the first variation the main line, and the rest variations the\n     * variations of the now main line</li>\n     * <li>the first move of some variation: delete the whole variation</li>\n     * <li>some move in the variation (not the first): delete the rest moves of that variation</li>\n     * </ul>\n     */\n    let deleteMove = function(id) {\n        /**\n         * Removes the object at index from the array, returns the object.\n         */\n        const removeFromArray = function(array, index) {\n            const ret = array[index];\n            array.splice(index, 1);\n            return ret;\n        };\n\n        if (isDeleted(id)) {\n            return;\n        }\n        // 1. Main line first move\n        if (id === 0) {\n            // Delete all moves\n            that.moves = [];\n            return;\n        }\n        let current = getMove(id);\n        // 2. First move of variation\n        if (startVariation(current)) {\n            const vars = getMove(getMove(current.prev).next).variations;\n            for (let i = 0; vars.length; i++) {\n                if (vars[i] === current) {\n                    removeFromArray(vars, i);\n                    if (current.next !== undefined) {\n                       deleteMove(current.next);\n                    }\n                    getMoves()[current.index] = null;\n                    return;\n                }\n            }\n        }\n        // 3. Some line some other move, no variation\n        if (current.variations.length === 0) {\n            if (current.next !== undefined && (current.next !== null)) {\n                deleteMove(current.next);\n            }\n            that.moves[current.prev].next = null;\n            that.moves[id] = null;\n            return;\n        }\n        // 4. Some line some other move, with variation\n        if (current.variations.length > 0) {\n            if (current.next !== undefined) {\n                deleteMove(current.next);\n            }\n            let variationMove = removeFromArray(current.variations, 0);\n            let varLevel = variationMove.variationLevel;\n            that.moves[current.prev].next = variationMove.index;\n            that.moves[id] = null;\n            updateVariationLevel(variationMove, varLevel - 1);\n        }\n    };\n\n    /**\n     * Find a move from a given representation. This may be an index, or a FEN string, or a notation.\n     */\n    function findMove(moveRep) {\n        if (!isNaN(moveRep)) {   // the following goes only over the main line, move number cannot denote a variation\n            moveRep = moveRep - 1;\n            let move = getMove(0);\n            while (moveRep > 0) {\n                moveRep = moveRep - 1;\n                move = getMove(move.next);\n            }\n            return move;\n        }\n        let moves = getMoves();\n        for (let move of moves) {\n            if (move.fen.startsWith(moveRep)) {\n                return move;\n            } else if (move.notation.notation === moveRep) {\n                return move;\n            }\n        }\n        return undefined;\n    }\n\n    /**\n     * Delete the moves before the current move, but without deleting the rest.\n     * TODO: This should be written in such a way, that this is only used when the game\n     * has not already started, so when loading the moves and interpreting them\n     * 3 cases:\n     * 1. Nothing special, just skip that.\n     * 2. startPlay is set, nothing to do here as well.\n     * 3. hideMovesBefore == true: Ensure that everything is done again after having called this function.\n     * \n     * So no, this should not be called from the UI, but when reading the moves.\n     * @param id\n     */\n    let deleteMovesBefore = function(id) {\n        // Inner function, that really deletes\n        let deleteMovesBeforeIncluding = function (id) {\n            let my_fen = that.moves[id].fen\n            that.moves[id] = null;\n            if (id <= 0) return my_fen;\n            deleteMovesBeforeIncluding(id - 1);\n            return my_fen;\n        };\n        if (id === undefined) return;\n        if (id === null) return;\n        if (id <= 0) return;\n        let my_fen = deleteMovesBeforeIncluding(id - 1);\n        getMove(id).prev = null;\n        return my_fen // Need position to start game here\n    };\n\n    /**\n     * Promotes the variation that is denoted by the move ID.\n     * These are the relevant cases:\n     * <ul>\n     * <li>Move is part of the main line: no promotion</li>\n     * <li>Move is part of the first variation: move the variation to the next level (or main line), make the previous promoted line the first variation.</li>\n     * <li>Move is part of second or higher variation: just switch index of variation arrays</li>\n     * </ul>\n     */\n    const promoteMove = function (id) {\n        /**\n         * Returns the first move of a variation.\n         */\n        const firstMoveOfVariation = function(move) {\n            if (startVariation(move)) {\n                return move;\n            }\n            return firstMoveOfVariation(getMove(move.prev));\n        };\n        const move = getMove(id);\n        // 1. Check that is variation\n        if ((typeof move.variationLevel == \"undefined\") || (move.variationLevel === 0)) {\n            return;\n        }\n\n        // 2. Get the first move of the variation\n        const myFirst = firstMoveOfVariation(move);\n\n        // 3. Get the index of that moves variation array\n        const higherVariationMove = getMove(getMove(myFirst.prev).next);\n        let indexVariation;\n        for (let i = 0; i < higherVariationMove.variations.length; i++) {\n            if (higherVariationMove.variations[i] === myFirst) {\n                indexVariation = i;\n            }\n        }\n\n        // 4. If variation index is > 0 (not the first variation)\n        if (indexVariation > 0) {\n            // Just switch with the previous index\n            let tmpMove = higherVariationMove.variations[indexVariation-1];\n            higherVariationMove.variations[indexVariation-1] = higherVariationMove.variations[indexVariation];\n            higherVariationMove.variations[indexVariation] = tmpMove;\n        } else {\n            // 5. Now the most difficult case: create new array from line above, switch that with\n            // the variation\n            let tmpMove = higherVariationMove;\n            const tmpVariations = higherVariationMove.variations;\n            const prevMove = getMove(higherVariationMove.prev);\n            prevMove.next = myFirst.index;\n            tmpMove.variations = myFirst.variations;\n            myFirst.variations = tmpVariations;\n            myFirst.variations[0] = tmpMove;\n        }\n        // Update the variation level because there will be changes\n        updateVariationLevel();\n    };\n\n\n    // Returns true, if the move is the start of teh main line\n    const startMainLine = function(move) {\n        return  move.variationLevel === 0 && (typeof move.prev !== \"number\") ;\n    };\n\n    // Returns true, if the move is the start of a (new) variation\n    const startVariation = function(move) {\n        return  move.variationLevel > 0 &&\n            ( (typeof move.prev != \"number\") || (getMoves()[move.prev].next !== move.index));\n    };\n    // Returns true, if the move is the end of a variation\n    const endVariation = function(move) {\n        return move.variationLevel > 0 && ! move.next;\n    };\n\n    // Returns true, if the move is after a move with at least one variation\n    const afterMoveWithVariation = function(move) {\n        return getMoves()[move.prev] && (getMoves()[move.prev].variations.length > 0);\n    };\n\n    /**\n     * Writes the pgn (fully) of the current game. The algorithm goes like that:\n     * * Start with the first move (there has to be only one in the main line)\n     * * For each move (call that recursively)\n     * * print-out the move itself\n     * * then the variations (one by one)\n     * * then the next move of the main line\n     * @return the string of all moves\n     */\n    const write_pgn = function() {\n\n        // Prepend a space if necessary\n        function prepend_space(sb) {\n            if ( (!sb.isEmpty()) && (sb.lastChar() !== \" \")) {\n                sb.append(\" \");\n            }\n        }\n\n        const write_comment = function(comment, sb) {\n            if (comment === undefined || comment === null) {\n                return;\n            }\n            prepend_space(sb);\n            sb.append(\"{\");\n            sb.append(comment);\n            sb.append(\"}\");\n        };\n\n        const write_comment_move = function(move, sb) {\n            write_comment(move.commentMove, sb);\n        };\n\n        const write_comment_before = function(move, sb) {\n            write_comment(move.commentBefore, sb);\n        };\n\n        const write_comment_after = function(move, sb) {\n            write_comment(move.commentAfter, sb);\n        };\n\n        const write_comment_diag = function(move, sb) {\n            let has_diags = (move) => {\n                return move.commentDiag &&\n                    ( ( move.commentDiag.colorArrows && move.commentDiag.colorArrows.length > 0 ) ||\n                      ( move.commentDiag.colorFields && move.commentDiag.colorFields.length > 0 )\n                );\n            }\n            let arrows = (move) => { return move.commentDiag.colorArrows || []; }\n            let fields = (move) => { return move.commentDiag.colorFields || []; }\n\n            if (has_diags(move)) {\n                let sbdiags = StringBuilder(\"\");\n                let first = true\n                sbdiags.append(\"[%csl \")\n                fields(move).forEach( (field) => {\n                    ! first ? sbdiags.append(\",\") : sbdiags.append(\"\");\n                    first = false;\n                    sbdiags.append(field);\n                });\n                sbdiags.append(\"]\");\n                first = true\n                sbdiags.append(\"[%cal \")\n                arrows(move).forEach( (arrow) => {\n                    ! first ? sbdiags.append(\",\") : sbdiags.append(\"\")\n                    first = false;\n                    sbdiags.append(arrow);\n                });\n                sbdiags.append(\"]\");\n                write_comment(sbdiags.toString(), sb);\n            }\n        }\n\n        const write_move_number = function (move, sb) {\n            prepend_space(sb);\n            if (move.turn === \"w\") {\n                sb.append(\"\" + move.moveNumber);\n                sb.append(\".\");\n            } else if (startVariation(move)) {\n                sb.append(\"\" + move.moveNumber);\n                sb.append(\"...\");\n            }\n        };\n\n        const write_notation = function (move, sb) {\n            prepend_space(sb);\n            sb.append(move.notation.notation);\n        };\n\n        const write_NAGs = function(move, sb) {\n            if (move.nag) {\n                move.nag.forEach(function(ele) {\n                    sb.append(ele);\n                });\n            }\n        };\n\n        const write_variation = function (move, sb) {\n            prepend_space(sb);\n            sb.append(\"(\");\n            write_move(move, sb);\n            prepend_space(sb);\n            sb.append(\")\");\n        };\n\n        const write_variations = function (move, sb) {\n            for (let i = 0; i < move.variations.length; i++) {\n                write_variation(move.variations[i], sb);\n            }\n        };\n\n        const get_next_move = function (move) {\n            return move.next ? getMove(move.next) : null;\n        };\n\n        /**\n         * Write the normalised notation: comment move, move number (if necessary),\n         * comment before, move, NAGs, comment after, variations.\n         * Then go into recursion for the next move.\n         * @param move the move in the exploded format\n         * @param sb the string builder to use\n         */\n        const write_move = function(move, sb) {\n            if (move === null || move === undefined) {\n                return;\n            }\n            write_comment_move(move, sb);\n            write_move_number(move, sb);\n            write_comment_before(move, sb);\n            write_notation(move, sb);\n            //write_check_or_mate(move, sb);    // not necessary if san from chess.src is used\n            write_NAGs(move, sb);\n            write_comment_after(move, sb);\n            write_comment_diag(move, sb);\n            write_variations(move, sb);\n            const next = get_next_move(move);\n            write_move(next, sb);\n        };\n\n        const write_end_game = function(_sb) {\n            if (that.endGame) {\n                _sb.append(\" \");\n                _sb.append(that.endGame);\n            }\n        };\n\n        const write_pgn2 = function(move, _sb) {\n\n            write_move(move, _sb);\n            write_end_game(_sb);\n            return _sb.toString();\n        };\n        const sb = StringBuilder(\"\");\n        let indexFirstMove = 0;\n        while (getMove(indexFirstMove) === null) { indexFirstMove += 1; }\n        return write_pgn2(getMove(indexFirstMove), sb);\n    };\n\n    /**\n     * Return true if the diagram NAG (== $220) is found.\n     * @param move\n     */\n    const has_diagram_nag = function(move) {\n        if (typeof move.nag == \"undefined\") return false;\n        if (move.nag == null) return false;\n        return move.nag.indexOf('$220') > -1;\n    };\n\n    /**\n     * Final algorithm to read and map the moves. Seems to be tricky ...\n     * @param movesMainLine all the moves of the game\n     */\n    const eachMove = function(movesMainLine) {\n        that.moves = [];\n        let current = -1;\n        /**\n         * Search for the right previous move. Go back until you find a move on the same\n         * level. Only used inside the eachMode algorithm\n         * @param level the current level to the move\n         * @param index the current index where the search (backwards) should start\n         * @returns {*} the resulting move or null, if none was found (should not happen)\n         */\n        const findPrevMove = function(level, index) {\n            while (index >= 0) {\n                if (that.moves[index].variationLevel === level) {\n                    return that.moves[index];\n                }\n                index--;\n            }\n            return null;\n        };\n        /**\n         * Recursive call that does the whole work\n         * @param moveArray move array, first call with the main line\n         * @param level the level of variation, 0 for the main line\n         * @param prev the index of the previous move\n         *          * null when main line and the first move\n         *          * the correct one if the index is 0\n         *          * overwritten by current - 1 if iterating and not the first move\n         */\n        const eachMoveVariation = function(moveArray, level, prev) {\n            // Computes the correct move numer from the position\n            const getMoveNumberFromPosition = function(fen) {\n                const tokens = fen.split(/\\s+/);\n                const move_number = parseInt(tokens[5], 10);\n                return (tokens[1] === 'b') ? move_number : move_number - 1;\n            };\n            let prevMove = (prev != null ? that.moves[prev] : null);\n            utils.pvEach(moveArray, function(move, i) {\n                current++;\n                move.variationLevel = level;\n                that.moves.push(move);\n                if (i > 0) {\n                    if (that.moves[current - 1].variationLevel > level) {\n                        prevMove = findPrevMove(level, current -1);\n                        prev = prevMove.index;\n                    } else {\n                        prev = current - 1;\n                        prevMove = that.moves[prev];\n                    }\n                }\n                wireMoves(current, prev, move, prevMove);\n                // Checks the move on a real board, and hold the fen\n                // TODO: Use the position from the configuration, to ensure, that games\n                // could be played not starting at the start position.\n                if (typeof move.prev == \"number\") {\n                    game.load(getMove(move.prev).fen);\n                } else {\n                    set_to_start();\n                }\n                let pgn_move = game.move(move.notation.notation, {'sloppy' : true});\n                if (pgn_move === null) {\n                    throw \"No legal move: \" + move.notation.notation;\n                }\n                let fen = game.fen();\n                move.fen = fen;\n                move.from = pgn_move.from;\n                move.to = pgn_move.to;\n                move.notation.notation = pgn_move.san;\n\n                if (pgn_move.flags === 'c') {\n                    move.notation.strike = 'x';\n                }\n                if (game.in_checkmate()) {\n                    move.notation.check = '#';\n                } else if (game.in_check()) {\n                    move.notation.check = '+';\n                }\n                move.moveNumber = getMoveNumberFromPosition(fen);\n\n                utils.pvEach(move.variations, function(variation) {\n                    eachMoveVariation(variation, level + 1, prev);\n                });\n            });\n        };\n        that.firstMove = movesMainLine[0];\n        eachMoveVariation(movesMainLine, 0, null);\n    };\n\n    /**\n     * Returns a map of possible moves.\n     * @param {*} game the chess to use\n     */\n    let possibleMoves = function(game) {\n        const dests = {};\n        game.SQUARES.forEach(s => {\n          const ms = game.moves({square: s, verbose: true});\n          if (ms.length) dests[s] = ms.map(m => m.to);\n        });\n        return dests;\n    };\n\n    /**\n     * Adds the move to the current state after moveNumber.\n     * In all cases the following has to be done:\n     * * compute a complete move object\n     * * Add that to the end of moves (returning the index)\n     * * Wire the previous move to that new one\n     *\n     * Depending on the current situation, the following will be necessary:\n     * * add to the end of the main line\n     * * add to the end of a variation\n     * * add as a new variation to the current one\n     * * completely ignore it, because the move is already there\n     * @param move the move notation (simplest form)\n     * @param moveNumber the number of the previous made move, null if it is the first one\n     */\n    const addMove = function (move, moveNumber) {\n        const get_turn = function (moveNumber) {\n              return getMove(moveNumber).turn === \"w\" ? 'b' : \"w\";\n        };\n\n        // Special case: first move, so there is no previous move\n        function existing_first_move(move) {\n            function first_move_notation() {\n                if (typeof getMove(0) == 'undefined') return null;\n                return getMove(0).notation.notation;\n            }\n            set_to_start();\n            let pgn_move = game.move(move);\n            if (typeof pgn_move == \"undefined\") {\n                return null;\n             } else if (first_move_notation() === pgn_move.san) {\n                return 0;\n             } else {   // TODO: Could be a variation of the first move ...\n                return existing_variation_first_move(pgn_move);\n             }\n        }\n\n        // Handles the first move that may be a variation of the first move, returns that.\n        // If not, returns null\n        function existing_variation_first_move(pgn_move) {\n            if (typeof getMove(0) == 'undefined') return null;\n            let variations = getMove(0).variations;\n            let vari;\n            for (vari in variations) {\n                if (variations[vari].notation.notation === pgn_move.san) return variations[vari].moveNumber;\n            }\n            return null; // no variation found\n        }\n\n        // Returns the existing move number or null\n        // Should include all variations as well\n        function existing_move(move, moveNumber) {\n            if (moveNumber == null) return existing_first_move(move);\n            let prevMove = getMove(moveNumber);\n            if (typeof prevMove == \"undefined\") return null;\n            game.load(prevMove.fen);\n            let pgn_move = game.move(move);\n            let nextMove = getMove(prevMove.next);\n            if (typeof nextMove == \"undefined\") return null;\n            if (nextMove.notation.notation === pgn_move.san) {\n                return prevMove.next;\n            } else { // check if there exists variations\n                let mainMove = getMove(prevMove.next);\n                for (let i = 0; i < mainMove.variations.length; i++) {\n                    let variation = mainMove.variations[i];\n                    if (variation.notation.notation === pgn_move.san) {\n                        return variation.index;\n                    }\n                }\n            }\n            return null;\n        }\n\n        // Handle possible variation\n        function handle_variation(move, prev, next) {\n            //console.log(\"handle variation: prev == \" + prev + \" next == \" + next);\n            let prevMove = getMove(prev);\n            if (prevMove === undefined) { // special case: variation on first move\n                if (next === 0) return; // First move\n                getMove(0).variations.push(move);\n                move.variationLevel = 1;\n                return;\n            }\n            if (prevMove.next) {    // has a next move set, so should be a variation\n                getMove(prevMove.next).variations.push(move);\n                move.variationLevel = (prevMove.variationLevel ? prevMove.variationLevel : 0) + 1;\n                if (move.turn === 'b') {\n                    move.moveNumber = prevMove.moveNumber;\n                }\n            } else {    // main variation\n                prevMove.next = next;\n                move.variationLevel = prevMove.variationLevel;\n            }\n        }\n\n        let curr = existing_move(move, moveNumber);\n        if (typeof curr == 'number') return curr;\n        let real_move = {};\n        real_move.from = move.from;\n        real_move.to = move.to;\n        real_move.notation = {};\n        real_move.variations = [];\n        if (moveNumber == null) {\n            set_to_start();\n            real_move.turn = game.turn();\n            real_move.moveNumber = 1;\n        } else {\n            game.load(getMove(moveNumber).fen);\n            real_move.turn = get_turn(moveNumber);\n            if (real_move.turn === \"w\") {\n                real_move.moveNumber = getMove(moveNumber).moveNumber + 1;\n            } else {\n                real_move.moveNumber = getMove(moveNumber).moveNumber;\n            }\n        }\n        let pgn_move = game.move(move);\n        real_move.fen = game.fen();\n        // san is the real notation, in case of O-O is that O-O.\n        // to is the to field, in case of (white) O-O is that g1.\n        if (pgn_move.san.substring(0,1) !== \"O\") {\n            real_move.notation.notation = pgn_move.san;\n            real_move.notation.col = pgn_move.to.substring(0,1);\n            real_move.notation.row = pgn_move.to.substring(1,2);\n            if (pgn_move.piece !== \"p\") {\n                real_move.notation.fig = pgn_move.piece.charAt(0).toUpperCase();\n            }\n            if (pgn_move.promotion) {\n                real_move.notation.promotion = '=' + pgn_move.promotion.toUpperCase();\n            }\n            if (pgn_move.flags.includes(game.FLAGS.CAPTURE) || (pgn_move.flags.includes(game.FLAGS.EP_CAPTURE))) {\n                real_move.notation.strike = 'x';\n            }\n            real_move.notation.ep = pgn_move.flags.includes(game.FLAGS.EP_CAPTURE)\n            if (game.in_check()) {\n                if (game.in_checkmate()) {\n                    real_move.notation.mate = '#';\n                } else {\n                    real_move.notation.check = '+';\n                }\n            }\n        } else {\n            real_move.notation.notation = pgn_move.san;\n        }\n        getMoves().push(real_move);\n        real_move.prev = moveNumber;\n        let next = getMoves().length - 1;\n        real_move.index = next;\n        handle_variation(real_move, moveNumber, next);\n        return next;\n    };\n\n    /**\n     * Adds the nag to the move with move number moveNumber\n     * @param nag the nag in normal notation or as symbol\n     * @param moveNumber the number of the move\n     * @param added true, if the nag should be added\n     */\n    const changeNag = function (nag, moveNumber, added) {\n        let move = getMove(moveNumber);\n        if (move.nag == null) {\n            move.nag = [];\n        }\n        let nagSym = (nag[0] === \"$\") ? nag : symbol_to_nag(nag);\n        if (added) {\n            if (move.nag.indexOf(nagSym) === -1) {\n                move.nag.push(nagSym);\n            }\n        } else {\n            let index = move.nag.indexOf(nagSym);\n            if (index > -1) {\n                move.nag.splice(index, 1);\n            }\n        }\n    };\n\n    const clearNags = function (moveNumber) {\n        let move = getMove(moveNumber);\n        move.nag = [];\n    };\n\n    /**\n     * Return all moves in the order they are displayed: move, variations of that move,\n     * next move, ...\n     */\n    const getOrderedMoves = function(current, returnedMoves) {\n        if (arguments.length === 0) {\n            current = getMove(that.startMove);\n            returnedMoves = [];\n        }\n        returnedMoves.push(current);\n        if (current.variations) {\n            for (let i = 0; i < current.variations.length; i++) {\n                getOrderedMoves(current.variations[i], returnedMoves);\n            }\n        }\n        if (current.next) {\n            return getOrderedMoves(getMove(current.next), returnedMoves);\n        } else {\n            return returnedMoves;\n        }\n    };\n\n    /**\n     * Return the moves of the main line.\n     */\n    const movesMainLine = function() {\n        let current = getMove(that.startMove);\n        let returnedMoves = [];\n        returnedMoves.push(current);\n        while (current.next) {\n            current = getMove(current.next);\n            returnedMoves.push(current);\n        }\n        return returnedMoves;\n    };\n\n    /**\n     * Returns the moves, ensures that the pgn string is read.\n     */\n    function getMoves() {\n        if (typeof that.moves != 'undefined') {\n            return that.moves;\n        } else {\n            load_pgn();\n            return that.moves;\n        }\n    }\n\n    /**\n     * Returns the tags. Ensures that pgn is already read.\n     */\n    function getTags() {\n        if (typeof that.tags != 'undefined') {\n            return that.tags;\n        } else {\n            load_pgn();\n            return that.tags;\n        }\n    }\n\n    function getEndGame() {\n        return that.endGame;\n    }\n\n    function setShapes(move, shapes) {\n        if (! move.commentDiag) {\n            move.commentDiag = {};\n        }\n        // Ensure everything is reset\n        move.commentDiag.colorArrows = [];\n        move.commentDiag.colorFields = [];\n\n        shapes.forEach( (shape) => {\n            if (shape.dest) { // arrow\n                let colArrow = shape.brush.slice(0,1).toUpperCase()\n                let arr = shape.orig + shape.dest;\n                move.commentDiag.colorArrows.push(colArrow + arr);\n            } else { // field\n                let colField = shape.brush.slice(0,1).toUpperCase();\n                let fie = shape.orig;\n                move.commentDiag.colorFields.push(colField + fie);\n            }\n        })\n    }\n\n    // This defines the public API of the pgn function.\n    return {\n        configuration: that.configuration,\n        deleteMove: deleteMove,\n        deleteMovesBefore: deleteMovesBefore,\n        isDeleted: isDeleted,\n        promoteMove: promoteMove,\n        readMoves: readMoves,\n        findMove: findMove,\n        getMoves: getMoves,\n        getOrderedMoves: getOrderedMoves,\n        getMove: getMove,\n        getEndGame: getEndGame,\n        getTags: getTags,\n//        splitHeaders: splitHeaders,\n        getParser: () => parser,\n//        eachMove: function() { return eachMove(); },\n        movesMainLine: movesMainLine,\n        write_pgn: write_pgn,\n        nag_to_symbol: nag_to_symbol,\n        startVariation: startVariation,\n        startMainLine: startMainLine,\n        endVariation: endVariation,\n        afterMoveWithVariation: afterMoveWithVariation,\n        changeNag: changeNag,\n        clearNags: clearNags,\n        addMove: addMove,\n        has_diagram_nag: has_diagram_nag,\n        PGN_NAGS: that.PGN_NAGS,\n        PROMOTIONS: that.PROMOTIONS,\n        NAGS: that.NAGs,\n        san: san,\n        sanWithNags: sanWithNags,\n        game: game,\n        load_pgn: load_pgn,\n        possibleMoves: possibleMoves,\n        setShapes: setShapes\n    };\n};\n\nexport { StringBuilder, Utils, pgnReader };\n\n"],"sourceRoot":""}